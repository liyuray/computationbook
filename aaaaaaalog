yj@yjlee1:~/gnusrc/computationbook$ for x in {the_meaning_of_programs,the_simplest_computers,just_add_power,the_ultimate_machine,programming_with_nothing,universality_is_everywhere,impossible_programs,programming_in_toyland}/irb.txt.tx; do bundle exec irb -I. -r `dirname $x`.rb $x    ; done
irb.txt.tx(main):001:0> Add.new(
irb.txt.tx(main):002:1*       Multiply.new(Number.new(1), Number.new(2)),
irb.txt.tx(main):003:1*       Multiply.new(Number.new(3), Number.new(4))
irb.txt.tx(main):004:1>   )
=>
#<struct Add
 left=#<struct Multiply left=#<struct Number value=1>, right=#<struct Number value=2>>,
 right=#<struct Multiply left=#<struct Number value=3>, right=#<struct Number value=4>>>
irb.txt.tx(main):005:0>
irb.txt.tx(main):006:0> Add.new(
irb.txt.tx(main):007:1*       Multiply.new(Number.new(1), Number.new(2)),
irb.txt.tx(main):008:1*       Multiply.new(Number.new(3), Number.new(4))
irb.txt.tx(main):009:1>   )
=>
#<struct Add
 left=#<struct Multiply left=#<struct Number value=1>, right=#<struct Number value=2>>,
 right=#<struct Multiply left=#<struct Number value=3>, right=#<struct Number value=4>>>
irb.txt.tx(main):010:0> Number.new(5)
=> #<struct Number value=5>
irb.txt.tx(main):011:0> Multiply.new(
irb.txt.tx(main):012:1*       Number.new(1),
irb.txt.tx(main):013:1*       Multiply.new(
irb.txt.tx(main):014:2*           Add.new(Number.new(2), Number.new(3)),
irb.txt.tx(main):015:2*           Number.new(4)
irb.txt.tx(main):016:2>       )
irb.txt.tx(main):017:1>   )
=>
#<struct Multiply
 left=#<struct Number value=1>,
 right=#<struct Multiply left=#<struct Add left=#<struct Number value=2>, right=#<struct Number value=3>>, right=#<struct Number value=4>>>
irb.txt.tx(main):018:0>
irb.txt.tx(main):019:0> Number.new(1).reducible?
=> false
irb.txt.tx(main):020:0> Add.new(Number.new(1), Number.new(2)).reducible?
=> true
irb.txt.tx(main):021:0>
irb.txt.tx(main):022:0> expression =
irb.txt.tx(main):023:0*     Add.new(
irb.txt.tx(main):024:1*         Multiply.new(Number.new(1), Number.new(2)),
irb.txt.tx(main):025:1*         Multiply.new(Number.new(3), Number.new(4))
irb.txt.tx(main):026:1>     )
=>
#<struct Add
...
irb.txt.tx(main):027:0> expression.reducible?
=> true
irb.txt.tx(main):028:0> expression = expression.reduce
/home/yj/gnusrc/computationbook/the_meaning_of_programs/small_step/add.rb:9:in `reduce': wrong number of arguments (given 0, expected 1) (ArgumentError)
        from the_meaning_of_programs/irb.txt.tx:28:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):029:0> expression.reducible?
=> true
irb.txt.tx(main):030:0> expression = expression.reduce
/home/yj/gnusrc/computationbook/the_meaning_of_programs/small_step/add.rb:9:in `reduce': wrong number of arguments (given 0, expected 1) (ArgumentError)
        from the_meaning_of_programs/irb.txt.tx:30:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):031:0> expression.reducible?
=> true
irb.txt.tx(main):032:0> expression = expression.reduce
/home/yj/gnusrc/computationbook/the_meaning_of_programs/small_step/add.rb:9:in `reduce': wrong number of arguments (given 0, expected 1) (ArgumentError)
        from the_meaning_of_programs/irb.txt.tx:32:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):033:0> expression.reducible?
=> true
irb.txt.tx(main):034:0>
irb.txt.tx(main):035:0> ExpressionMachine.new(
irb.txt.tx(main):036:1*       Add.new(
irb.txt.tx(main):037:2*           Multiply.new(Number.new(1), Number.new(2)),
irb.txt.tx(main):038:2*           Multiply.new(Number.new(3), Number.new(4))
irb.txt.tx(main):039:2>       )
irb.txt.tx(main):040:1>   ).run
1 * 2 + 3 * 4
2 + 3 * 4
2 + 12
14
=> nil
irb.txt.tx(main):041:0>
irb.txt.tx(main):042:0> ExpressionMachine.new(
irb.txt.tx(main):043:1*       LessThan.new(Number.new(5), Add.new(Number.new(2), Number.new(2)))
irb.txt.tx(main):044:1>   ).run
5 < 2 + 2
5 < 4
false
=> nil
irb.txt.tx(main):045:0>
irb.txt.tx(main):046:0> ExpressionMachine.new(
irb.txt.tx(main):047:1*       Add.new(Variable.new(:x), Variable.new(:y)),
irb.txt.tx(main):048:1*       { x: Number.new(3), y: Number.new(4) }
irb.txt.tx(main):049:1>   ).run
x + y
3 + y
3 + 4
7
=> nil
irb.txt.tx(main):050:0>
irb.txt.tx(main):051:0> old_environment = { y: Number.new(5) }
=> {:y=>#<struct Number value=5>}
irb.txt.tx(main):052:0> new_environment = old_environment.merge({ x: Number.new(3) })
=> {:y=>#<struct Number value=5>, :x=>#<struct Number value=3>}
irb.txt.tx(main):053:0> old_environment
=> {:y=>#<struct Number value=5>}
irb.txt.tx(main):054:0>
irb.txt.tx(main):055:0> statement = Assign.new(:x, Add.new(Variable.new(:x), Number.new(1)))
=> #<struct Assign name=:x, expression=#<struct Add left=#<struct Variable ...
irb.txt.tx(main):056:0> environment = { x: Number.new(2) }
=> {:x=>#<struct Number value=2>}
irb.txt.tx(main):057:0> statement.reducible?
=> true
irb.txt.tx(main):058:0> statement, environment = statement.reduce(environment)
=> [#<struct Assign name=:x, expression=#<struct Add left=#<struct Number v...
irb.txt.tx(main):059:0> statement, environment = statement.reduce(environment)
=> [#<struct Assign name=:x, expression=#<struct Number value=3>>, {:x=>#<s...
irb.txt.tx(main):060:0> statement, environment = statement.reduce(environment)
=> [«do-nothing», {:x=>#<struct Number value=3>}]
irb.txt.tx(main):061:0> statement.reducible?
=> false
irb.txt.tx(main):062:0>
irb.txt.tx(main):063:0> StatementMachine.new(
irb.txt.tx(main):064:1*       Assign.new(:x, Add.new(Variable.new(:x), Number.new(1))),
irb.txt.tx(main):065:1*       { x: Number.new(2) }
irb.txt.tx(main):066:1>   ).run
x = x + 1, {:x=>«2»}
x = 2 + 1, {:x=>«2»}
x = 3, {:x=>«2»}
do-nothing, {:x=>«3»}
=> nil
irb.txt.tx(main):067:0>
irb.txt.tx(main):068:0> StatementMachine.new(
irb.txt.tx(main):069:1*       If.new(
irb.txt.tx(main):070:2*           Variable.new(:x),
irb.txt.tx(main):071:2*           Assign.new(:y, Number.new(1)),
irb.txt.tx(main):072:2*           Assign.new(:y, Number.new(2))
irb.txt.tx(main):073:2>       ),
irb.txt.tx(main):074:1*       { x: Boolean.new(true) }
irb.txt.tx(main):075:1>   ).run
if (x) { y = 1 } else { y = 2 }, {:x=>«true»}
if (true) { y = 1 } else { y = 2 }, {:x=>«true»}
y = 1, {:x=>«true»}
do-nothing, {:x=>«true», :y=>«1»}
=> nil
irb.txt.tx(main):076:0> StatementMachine.new(
irb.txt.tx(main):077:1*       If.new(Variable.new(:x), Assign.new(:y, Number.new(1)), DoNothing.new),
irb.txt.tx(main):078:1*       { x: Boolean.new(false) }
irb.txt.tx(main):079:1>   ).run
if (x) { y = 1 } else { do-nothing }, {:x=>«false»}
if (false) { y = 1 } else { do-nothing }, {:x=>«false»}
do-nothing, {:x=>«false»}
=> nil
irb.txt.tx(main):080:0>
irb.txt.tx(main):081:0> StatementMachine.new(
irb.txt.tx(main):082:1*       Sequence.new(
irb.txt.tx(main):083:2*           Assign.new(:x, Add.new(Number.new(1), Number.new(1))),
irb.txt.tx(main):084:2*           Assign.new(:y, Add.new(Variable.new(:x), Number.new(3)))
irb.txt.tx(main):085:2>       ),
irb.txt.tx(main):086:1*       {}
irb.txt.tx(main):087:1>   ).run
x = 1 + 1; y = x + 3, {}
x = 2; y = x + 3, {}
do-nothing; y = x + 3, {:x=>«2»}
y = x + 3, {:x=>«2»}
y = 2 + 3, {:x=>«2»}
y = 5, {:x=>«2»}
do-nothing, {:x=>«2», :y=>«5»}
=> nil
irb.txt.tx(main):088:0>
irb.txt.tx(main):089:0> StatementMachine.new(
irb.txt.tx(main):090:1*       While.new(
irb.txt.tx(main):091:2*           LessThan.new(Variable.new(:x), Number.new(5)),
irb.txt.tx(main):092:2*           Assign.new(:x, Multiply.new(Variable.new(:x), Number.new(3)))
irb.txt.tx(main):093:2>       ),
irb.txt.tx(main):094:1*       { x: Number.new(1) }
irb.txt.tx(main):095:1>   ).run
while (x < 5) { x = x * 3 }, {:x=>«1»}
if (x < 5) { x = x * 3; while (x < 5) { x = x * 3 } } else { do-nothing }, {:x=>«1»}
if (1 < 5) { x = x * 3; while (x < 5) { x = x * 3 } } else { do-nothing }, {:x=>«1»}
if (true) { x = x * 3; while (x < 5) { x = x * 3 } } else { do-nothing }, {:x=>«1»}
x = x * 3; while (x < 5) { x = x * 3 }, {:x=>«1»}
x = 1 * 3; while (x < 5) { x = x * 3 }, {:x=>«1»}
x = 3; while (x < 5) { x = x * 3 }, {:x=>«1»}
do-nothing; while (x < 5) { x = x * 3 }, {:x=>«3»}
while (x < 5) { x = x * 3 }, {:x=>«3»}
if (x < 5) { x = x * 3; while (x < 5) { x = x * 3 } } else { do-nothing }, {:x=>«3»}
if (3 < 5) { x = x * 3; while (x < 5) { x = x * 3 } } else { do-nothing }, {:x=>«3»}
if (true) { x = x * 3; while (x < 5) { x = x * 3 } } else { do-nothing }, {:x=>«3»}
x = x * 3; while (x < 5) { x = x * 3 }, {:x=>«3»}
x = 3 * 3; while (x < 5) { x = x * 3 }, {:x=>«3»}
x = 9; while (x < 5) { x = x * 3 }, {:x=>«3»}
do-nothing; while (x < 5) { x = x * 3 }, {:x=>«9»}
while (x < 5) { x = x * 3 }, {:x=>«9»}
if (x < 5) { x = x * 3; while (x < 5) { x = x * 3 } } else { do-nothing }, {:x=>«9»}
if (9 < 5) { x = x * 3; while (x < 5) { x = x * 3 } } else { do-nothing }, {:x=>«9»}
if (false) { x = x * 3; while (x < 5) { x = x * 3 } } else { do-nothing }, {:x=>«9»}
do-nothing, {:x=>«9»}
=> nil
irb.txt.tx(main):096:0>
irb.txt.tx(main):097:0> StatementMachine.new(
irb.txt.tx(main):098:1*       Sequence.new(
irb.txt.tx(main):099:2*           Assign.new(:x, Boolean.new(true)),
irb.txt.tx(main):100:2*           Assign.new(:x, Add.new(Variable.new(:x), Number.new(1)))
irb.txt.tx(main):101:2>       ),
irb.txt.tx(main):102:1*       {}
irb.txt.tx(main):103:1>   ).run
x = true; x = x + 1, {}
do-nothing; x = x + 1, {:x=>«true»}
x = x + 1, {:x=>«true»}
x = true + 1, {:x=>«true»}
/home/yj/gnusrc/computationbook/the_meaning_of_programs/small_step/add.rb:15:in `reduce': undefined method `+' for true:TrueClass (NoMethodError)
        from /home/yj/gnusrc/computationbook/the_meaning_of_programs/small_step/assign.rb:11:in `reduce'
        from /home/yj/gnusrc/computationbook/the_meaning_of_programs/small_step/statement_machine.rb:3:in `step'
        from /home/yj/gnusrc/computationbook/the_meaning_of_programs/small_step/statement_machine.rb:9:in `run'
        from the_meaning_of_programs/irb.txt.tx:103:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        ... 6 levels...
irb.txt.tx(main):104:0>
irb.txt.tx(main):105:0> Number.new(23).evaluate({})
=> #<struct Number value=23>
irb.txt.tx(main):106:0> Variable.new(:x).evaluate({ x: Number.new(23) })
=> #<struct Number value=23>
irb.txt.tx(main):107:0> LessThan.new(
irb.txt.tx(main):108:1*       Add.new(Variable.new(:x), Number.new(2)),
irb.txt.tx(main):109:1*       Variable.new(:y)
irb.txt.tx(main):110:1>   ).evaluate({ x: Number.new(2), y: Number.new(5) })
=> #<struct Boolean value=true>
irb.txt.tx(main):111:0>
irb.txt.tx(main):112:0> statement =
irb.txt.tx(main):113:0*     Sequence.new(
irb.txt.tx(main):114:1*         Assign.new(:x, Add.new(Number.new(1), Number.new(1))),
irb.txt.tx(main):115:1*         Assign.new(:y, Add.new(Variable.new(:x), Number.new(3)))
irb.txt.tx(main):116:1>     )
=>
#<struct Sequence
...
irb.txt.tx(main):117:0> statement.evaluate({})
=> {:x=>#<struct Number value=2>, :y=>#<struct Number value=5>}
irb.txt.tx(main):118:0>
irb.txt.tx(main):119:0> statement =
irb.txt.tx(main):120:0*     While.new(
irb.txt.tx(main):121:1*         LessThan.new(Variable.new(:x), Number.new(5)),
irb.txt.tx(main):122:1*         Assign.new(:x, Multiply.new(Variable.new(:x), Number.new(3)))
irb.txt.tx(main):123:1>     )
=>
#<struct While
...
irb.txt.tx(main):124:0> statement.evaluate({ x: Number.new(1) })
=> {:x=>#<struct Number value=9>}
irb.txt.tx(main):125:0>
irb.txt.tx(main):126:0> Number.new(5).to_ruby
=> "-> e { 5 }"
irb.txt.tx(main):127:0> Boolean.new(false).to_ruby
=> "-> e { false }"
irb.txt.tx(main):128:0> proc = eval(Number.new(5).to_ruby)
=> #<Proc:0x000055e2d1630470 (eval):1 (lambda)>
irb.txt.tx(main):129:0> proc.call({})
=> 5
irb.txt.tx(main):130:0> proc = eval(Boolean.new(false).to_ruby)
=> #<Proc:0x000055e2d16be950 (eval):1 (lambda)>
irb.txt.tx(main):131:0> proc.call({})
=> false
irb.txt.tx(main):132:0>
irb.txt.tx(main):133:0> expression = Variable.new(:x)
=> #<struct Variable name=:x>
irb.txt.tx(main):134:0> expression.to_ruby
=> "-> e { e[:x] }"
irb.txt.tx(main):135:0> proc = eval(expression.to_ruby)
=> #<Proc:0x000055e2d16ef500 (eval):1 (lambda)>
irb.txt.tx(main):136:0> proc.call({ x: 7 })
=> 7
irb.txt.tx(main):137:0>
irb.txt.tx(main):138:0> Add.new(Variable.new(:x), Number.new(1)).to_ruby
=> "-> e { (-> e { e[:x] }).call(e) + (-> e { 1 }).call(e) }"
irb.txt.tx(main):139:0> LessThan.new(Add.new(Variable.new(:x), Number.new(1)), Number.new(3)).to_ruby
=> "-> e { (-> e { (-> e { e[:x] }).call(e) + (-> e { 1 }).call(e) }).call(e) < (-> e { 3 }).call(e) }"
irb.txt.tx(main):140:0> environment = { x: 3 }
=> {:x=>3}
irb.txt.tx(main):141:0> proc = eval(Add.new(Variable.new(:x), Number.new(1)).to_ruby)
=> #<Proc:0x000055e2d16feac8 (eval):1 (lambda)>
irb.txt.tx(main):142:0> proc.call(environment)
=> 4
irb.txt.tx(main):143:0> proc = eval(
irb.txt.tx(main):144:1*       LessThan.new(Add.new(Variable.new(:x), Number.new(1)), Number.new(3)).to_ruby
irb.txt.tx(main):145:1>   )
=> #<Proc:0x000055e2d1735aa0 (eval):1 (lambda)>
irb.txt.tx(main):146:0> proc.call(environment)
=> false
irb.txt.tx(main):147:0>
irb.txt.tx(main):148:0> statement = Assign.new(:y, Add.new(Variable.new(:x), Number.new(1)))
=> #<struct Assign name=:y, expression=#<struct Add left=#<struct Variable ...
irb.txt.tx(main):149:0> statement.to_ruby
=> "-> e { e.merge({ :y => (-> e { (-> e { e[:x] }).call(e) + (-> e { 1 }).call(e) }).call(e) }) }"
irb.txt.tx(main):150:0> proc = eval(statement.to_ruby)
=> #<Proc:0x000055e2d1246760 (eval):1 (lambda)>
irb.txt.tx(main):151:0> proc.call({ x: 3 })
=> {:x=>3, :y=>4}
irb.txt.tx(main):152:0>
irb.txt.tx(main):153:0> statement =
irb.txt.tx(main):154:0*     While.new(
irb.txt.tx(main):155:1*         LessThan.new(Variable.new(:x), Number.new(5)),
irb.txt.tx(main):156:1*         Assign.new(:x, Multiply.new(Variable.new(:x), Number.new(3)))
irb.txt.tx(main):157:1>     )
=>
#<struct While
...
irb.txt.tx(main):158:0> statement.to_ruby
=> "-> e { while (-> e { (-> e { e[:x] }).call(e) < (-> e { 5 }).call(e) }).call(e); e = (-> e { e.merge({ :x => (-> e { (-> e { e[:x] }).call(e) * (-> e { 3 }).call(e) }).call(e) }) }).call(e); end; e }"
irb.txt.tx(main):159:0> proc = eval(statement.to_ruby)
=> #<Proc:0x000055e2d1530e80 (eval):1 (lambda)>
irb.txt.tx(main):160:0> proc.call({ x: 1 })
=> {:x=>9}
irb.txt.tx(main):161:0>
irb.txt.tx(main):162:0> require 'treetop'
=> true
irb.txt.tx(main):163:0> Treetop.load('the_meaning_of_programs/parser/simple.treetop')
=> SimpleParser
irb.txt.tx(main):164:0> parse_tree = SimpleParser.new.parse('while (x < 5) { x = x * 3 }')
=> SyntaxNode+While1+While0 offset=0, "...x < 5) { x = x * 3 }" (to_ast,con...
irb.txt.tx(main):165:0> statement = parse_tree.to_ast
=>
#<struct While
...
irb.txt.tx(main):166:0> statement.evaluate({ x: Number.new(1) })
=> {:x=>#<struct Number value=9>}
irb.txt.tx(main):167:0> statement.to_ruby
=> "-> e { while (-> e { (-> e { e[:x] }).call(e) < (-> e { 5 }).call(e) }).call(e); e = (-> e { e.merge({ :x => (-> e { (-> e { e[:x] }).call(e) * (-> e { 3 }).call(e) }).call(e) }) }).call(e); end; e }"
irb.txt.tx(main):168:0> expression = SimpleParser.new.parse('1 * 2 * 3 * 4', root: :expression).to_ast
=>
#<struct Multiply
...
irb.txt.tx(main):169:0> expression.left
=> #<struct Number value=1>
irb.txt.tx(main):170:0> expression.right
=> #<struct Multiply left=#<struct Number value=2>, right=#<struct Multiply left=#<struct Number value=3>, right=#<struct Number value=4>>>
irb.txt.tx(main):171:0> exit
irb.txt.tx(main):001:0> rulebook = DFARulebook.new([
irb.txt.tx(main):002:2*         FARule.new(1, 'a', 2), FARule.new(1, 'b', 1),
irb.txt.tx(main):003:2*         FARule.new(2, 'a', 2), FARule.new(2, 'b', 3),
irb.txt.tx(main):004:2*         FARule.new(3, 'a', 3), FARule.new(3, 'b', 3)
irb.txt.tx(main):005:2>     ])
=>
#<struct DFARulebook
...
irb.txt.tx(main):006:0> rulebook.next_state(1, 'a')
=> 2
irb.txt.tx(main):007:0> rulebook.next_state(1, 'b')
=> 1
irb.txt.tx(main):008:0> rulebook.next_state(2, 'b')
=> 3
irb.txt.tx(main):009:0>
irb.txt.tx(main):010:0> DFA.new(1, [1, 3], rulebook).accepting?
=> true
irb.txt.tx(main):011:0> DFA.new(1, [3], rulebook).accepting?
=> false
irb.txt.tx(main):012:0>
irb.txt.tx(main):013:0> dfa = DFA.new(1, [3], rulebook); dfa.accepting?
=> false
irb.txt.tx(main):014:0> dfa.read_character('b'); dfa.accepting?
=> false
irb.txt.tx(main):015:0> 3.times do dfa.read_character('a') end; dfa.accepting?
=> false
irb.txt.tx(main):016:0> dfa.read_character('b'); dfa.accepting?
=> true
irb.txt.tx(main):017:0>
irb.txt.tx(main):018:0> dfa = DFA.new(1, [3], rulebook); dfa.accepting?
=> false
irb.txt.tx(main):019:0> dfa.read_string('baaab'); dfa.accepting?
=> true
irb.txt.tx(main):020:0>
irb.txt.tx(main):021:0> dfa_design = DFADesign.new(1, [3], rulebook)
=>
#<struct DFADesign
...
irb.txt.tx(main):022:0> dfa_design.accepts?('a')
=> false
irb.txt.tx(main):023:0> dfa_design.accepts?('baa')
=> false
irb.txt.tx(main):024:0> dfa_design.accepts?('baba')
=> true
irb.txt.tx(main):025:0>
irb.txt.tx(main):026:0> rulebook = NFARulebook.new([
irb.txt.tx(main):027:2*         FARule.new(1, 'a', 1), FARule.new(1, 'b', 1), FARule.new(1, 'b', 2),
irb.txt.tx(main):028:2*         FARule.new(2, 'a', 3), FARule.new(2, 'b', 3),
irb.txt.tx(main):029:2*         FARule.new(3, 'a', 4), FARule.new(3, 'b', 4)
irb.txt.tx(main):030:2>     ])
=>
#<struct NFARulebook
...
irb.txt.tx(main):031:0> rulebook.next_states(Set[1], 'b')
=> #<Set: {1, 2}>
irb.txt.tx(main):032:0> rulebook.next_states(Set[1, 2], 'a')
=> #<Set: {1, 3}>
irb.txt.tx(main):033:0> rulebook.next_states(Set[1, 3], 'b')
=> #<Set: {1, 2, 4}>
irb.txt.tx(main):034:0>
irb.txt.tx(main):035:0> NFA.new(Set[1], [4], rulebook).accepting?
=> false
irb.txt.tx(main):036:0> NFA.new(Set[1, 2, 4], [4], rulebook).accepting?
=> true
irb.txt.tx(main):037:0>
irb.txt.tx(main):038:0> nfa = NFA.new(Set[1], [4], rulebook); nfa.accepting?
=> false
irb.txt.tx(main):039:0> nfa.read_character('b'); nfa.accepting?
=> false
irb.txt.tx(main):040:0> nfa.read_character('a'); nfa.accepting?
=> false
irb.txt.tx(main):041:0> nfa.read_character('b'); nfa.accepting?
=> true
irb.txt.tx(main):042:0> nfa = NFA.new(Set[1], [4], rulebook)
=>
#<struct NFA
...
irb.txt.tx(main):043:0> nfa.accepting?
=> false
irb.txt.tx(main):044:0> nfa.read_string('bbbbb'); nfa.accepting?
=> true
irb.txt.tx(main):045:0>
irb.txt.tx(main):046:0> nfa_design = NFADesign.new(1, [4], rulebook)
=>
#<struct NFADesign
...
irb.txt.tx(main):047:0> nfa_design.accepts?('bab')
=> true
irb.txt.tx(main):048:0> nfa_design.accepts?('bbbbb')
=> true
irb.txt.tx(main):049:0> nfa_design.accepts?('bbabb')
=> false
irb.txt.tx(main):050:0> rulebook = NFARulebook.new([
irb.txt.tx(main):051:2*         FARule.new(1, nil, 2), FARule.new(1, nil, 4),
irb.txt.tx(main):052:2*         FARule.new(2, 'a', 3),
irb.txt.tx(main):053:2*         FARule.new(3, 'a', 2),
irb.txt.tx(main):054:2*         FARule.new(4, 'a', 5),
irb.txt.tx(main):055:2*         FARule.new(5, 'a', 6),
irb.txt.tx(main):056:2*         FARule.new(6, 'a', 4)
irb.txt.tx(main):057:2>     ])
=>
#<struct NFARulebook
...
irb.txt.tx(main):058:0> rulebook.next_states(Set[1], nil)
=> #<Set: {2, 4}>
irb.txt.tx(main):059:0>
irb.txt.tx(main):060:0> rulebook.follow_free_moves(Set[1])
=> #<Set: {1, 2, 4}>
irb.txt.tx(main):061:0>
irb.txt.tx(main):062:0> nfa_design = NFADesign.new(1, [2, 4], rulebook)
=>
#<struct NFADesign
...
irb.txt.tx(main):063:0> nfa_design.accepts?('aa')
=> true
irb.txt.tx(main):064:0> nfa_design.accepts?('aaa')
=> true
irb.txt.tx(main):065:0> nfa_design.accepts?('aaaaa')
=> false
irb.txt.tx(main):066:0> nfa_design.accepts?('aaaaaa')
=> true
irb.txt.tx(main):067:0>
irb.txt.tx(main):068:0> pattern =
irb.txt.tx(main):069:0*     Repeat.new(
irb.txt.tx(main):070:1*         Choose.new(
irb.txt.tx(main):071:2*             Concatenate.new(Literal.new('a'), Literal.new('b')),
irb.txt.tx(main):072:2*             Literal.new('a')
irb.txt.tx(main):073:2>         )
irb.txt.tx(main):074:1>     )
=>
#<struct Repeat
...
irb.txt.tx(main):075:0>
irb.txt.tx(main):076:0> nfa_design = Empty.new.to_nfa_design
=> #<struct NFADesign start_state=#<Object:0x000055a66f4eca30>, accept_stat...
irb.txt.tx(main):077:0> nfa_design.accepts?('')
=> true
irb.txt.tx(main):078:0> nfa_design.accepts?('a')
=> false
irb.txt.tx(main):079:0> nfa_design = Literal.new('a').to_nfa_design
=>
#<struct NFADesign
...
irb.txt.tx(main):080:0> nfa_design.accepts?('')
=> false
irb.txt.tx(main):081:0> nfa_design.accepts?('a')
=> true
irb.txt.tx(main):082:0> nfa_design.accepts?('b')
=> false
irb.txt.tx(main):083:0>
irb.txt.tx(main):084:0> Empty.new.matches?('a')
=> false
irb.txt.tx(main):085:0> Literal.new('a').matches?('a')
=> true
irb.txt.tx(main):086:0>
irb.txt.tx(main):087:0> pattern = Concatenate.new(Literal.new('a'), Literal.new('b'))
=> #<struct Concatenate first=#<struct Literal character="a">, second=#<str...
irb.txt.tx(main):088:0> pattern.matches?('a')
=> false
irb.txt.tx(main):089:0> pattern.matches?('ab')
=> true
irb.txt.tx(main):090:0> pattern.matches?('abc')
=> false
irb.txt.tx(main):091:0> pattern =
irb.txt.tx(main):092:0*     Concatenate.new(
irb.txt.tx(main):093:1*         Literal.new('a'),
irb.txt.tx(main):094:1*         Concatenate.new(Literal.new('b'), Literal.new('c'))
irb.txt.tx(main):095:1>     )
=>
#<struct Concatenate
...
irb.txt.tx(main):096:0> pattern.matches?('a')
=> false
irb.txt.tx(main):097:0> pattern.matches?('ab')
=> false
irb.txt.tx(main):098:0> pattern.matches?('abc')
=> true
irb.txt.tx(main):099:0>
irb.txt.tx(main):100:0> pattern = Choose.new(Literal.new('a'), Literal.new('b'))
=> #<struct Choose first=#<struct Literal character="a">, second=#<struct L...
irb.txt.tx(main):101:0> pattern.matches?('a')
=> true
irb.txt.tx(main):102:0> pattern.matches?('b')
=> true
irb.txt.tx(main):103:0> pattern.matches?('c')
=> false
irb.txt.tx(main):104:0>
irb.txt.tx(main):105:0> pattern = Repeat.new(Literal.new('a'))
=> #<struct Repeat pattern=#<struct Literal character="a">>
irb.txt.tx(main):106:0> pattern.matches?('')
=> true
irb.txt.tx(main):107:0> pattern.matches?('a')
=> true
irb.txt.tx(main):108:0> pattern.matches?('aaaa')
=> true
irb.txt.tx(main):109:0> pattern.matches?('b')
=> false
irb.txt.tx(main):110:0> pattern =
irb.txt.tx(main):111:0*     Repeat.new(
irb.txt.tx(main):112:1*         Concatenate.new(
irb.txt.tx(main):113:2*             Literal.new('a'),
irb.txt.tx(main):114:2*             Choose.new(Empty.new, Literal.new('b'))
irb.txt.tx(main):115:2>         )
irb.txt.tx(main):116:1>     )
=> #<struct Repeat pattern=#<struct Concatenate first=#<struct Literal char...
irb.txt.tx(main):117:0> pattern.matches?('')
=> true
irb.txt.tx(main):118:0> pattern.matches?('a')
=> true
irb.txt.tx(main):119:0> pattern.matches?('ab')
=> true
irb.txt.tx(main):120:0> pattern.matches?('aba')
=> true
irb.txt.tx(main):121:0> pattern.matches?('abab')
=> true
irb.txt.tx(main):122:0> pattern.matches?('abaab')
=> true
irb.txt.tx(main):123:0> pattern.matches?('abba')
=> false
irb.txt.tx(main):124:0>
irb.txt.tx(main):125:0> require 'treetop'
=> true
irb.txt.tx(main):126:0> Treetop.load('the_simplest_computers/regular_expressions/pattern')
=> PatternParser
irb.txt.tx(main):127:0> parse_tree = PatternParser.new.parse('(a(|b))*')
=>
SyntaxNode+Repeat1+Repeat0 offset=0, "(a(|b))*" (to_ast,brackets):
...
irb.txt.tx(main):128:0> pattern = parse_tree.to_ast
=> #<struct Repeat pattern=#<struct Concatenate first=#<struct Literal char...
irb.txt.tx(main):129:0> pattern.matches?('abaab')
=> true
irb.txt.tx(main):130:0> pattern.matches?('abba')
=> false
irb.txt.tx(main):131:0>
irb.txt.tx(main):132:0> rulebook = NFARulebook.new([
irb.txt.tx(main):133:2*         FARule.new(1, 'a', 1), FARule.new(1, 'a', 2), FARule.new(1, nil, 2),
irb.txt.tx(main):134:2*         FARule.new(2, 'b', 3),
irb.txt.tx(main):135:2*         FARule.new(3, 'b', 1), FARule.new(3, nil, 2)
irb.txt.tx(main):136:2>     ])
=>
#<struct NFARulebook
...
irb.txt.tx(main):137:0> nfa_design = NFADesign.new(1, [3], rulebook)
=>
#<struct NFADesign
...
irb.txt.tx(main):138:0> nfa_design.to_nfa.current_states
=> #<Set: {1, 2}>
irb.txt.tx(main):139:0> nfa_design.to_nfa(Set[2]).current_states
=> #<Set: {2}>
irb.txt.tx(main):140:0> nfa_design.to_nfa(Set[3]).current_states
=> #<Set: {3, 2}>
irb.txt.tx(main):141:0> nfa = nfa_design.to_nfa(Set[2, 3])
=>
#<struct NFA
...
irb.txt.tx(main):142:0> nfa.read_character('b'); nfa.current_states
=> #<Set: {3, 1, 2}>
irb.txt.tx(main):143:0>
irb.txt.tx(main):144:0> simulation = NFASimulation.new(nfa_design)
=>
#<struct NFASimulation
...
irb.txt.tx(main):145:0> simulation.next_state(Set[1, 2], 'a')
=> #<Set: {1, 2}>
irb.txt.tx(main):146:0> simulation.next_state(Set[1, 2], 'b')
=> #<Set: {3, 2}>
irb.txt.tx(main):147:0> simulation.next_state(Set[3, 2], 'b')
=> #<Set: {1, 3, 2}>
irb.txt.tx(main):148:0> simulation.next_state(Set[1, 3, 2], 'b')
=> #<Set: {1, 3, 2}>
irb.txt.tx(main):149:0> simulation.next_state(Set[1, 3, 2], 'a')
=> #<Set: {1, 2}>
irb.txt.tx(main):150:0>
irb.txt.tx(main):151:0> rulebook.alphabet
=> ["a", "b"]
irb.txt.tx(main):152:0> simulation.rules_for(Set[1, 2])
=> [#<struct FARule state=#<Set: {1, 2}>, character="a", next_state=#<Set: {1, 2}>>, #<struct FARule state=#<Set: {1, 2}>, character="b", next_state=#<Set: {3, 2}>>]
irb.txt.tx(main):153:0> simulation.rules_for(Set[3, 2])
=> [#<struct FARule state=#<Set: {3, 2}>, character="a", next_state=#<Set: {}>>, #<struct FARule state=#<Set: {3, 2}>, character="b", next_state=#<Set: {1, 3, 2}>>]
irb.txt.tx(main):154:0>
irb.txt.tx(main):155:0> start_state = nfa_design.to_nfa.current_states
=> #<Set: {1, 2}>
irb.txt.tx(main):156:0> simulation.discover_states_and_rules(Set[start_state])
=>
[#<Set: {#<Set: {1, 2}>, #<Set: {3, 2}>, #<Set: {}>, #<Set: {1, 3, 2}>}>,
 [#<struct FARule state=#<Set: {1, 2}>, character="a", next_state=#<Set: {1, 2}>>,
  #<struct FARule state=#<Set: {1, 2}>, character="b", next_state=#<Set: {3, 2}>>,
  #<struct FARule state=#<Set: {3, 2}>, character="a", next_state=#<Set: {}>>,
  #<struct FARule state=#<Set: {3, 2}>, character="b", next_state=#<Set: {1, 3, 2}>>,
  #<struct FARule state=#<Set: {}>, character="a", next_state=#<Set: {}>>,
  #<struct FARule state=#<Set: {}>, character="b", next_state=#<Set: {}>>,
  #<struct FARule state=#<Set: {1, 3, 2}>, character="a", next_state=#<Set: {1, 2}>>,
  #<struct FARule state=#<Set: {1, 3, 2}>, character="b", next_state=#<Set: {1, 3, 2}>>]]
irb.txt.tx(main):157:0> nfa_design.to_nfa(Set[1, 2]).accepting?
=> false
irb.txt.tx(main):158:0> nfa_design.to_nfa(Set[2, 3]).accepting?
=> true
irb.txt.tx(main):159:0>
irb.txt.tx(main):160:0> dfa_design = simulation.to_dfa_design
=>
#<struct DFADesign
...
irb.txt.tx(main):161:0> dfa_design.accepts?('aaa')
=> false
irb.txt.tx(main):162:0> dfa_design.accepts?('aab')
=> true
irb.txt.tx(main):163:0> dfa_design.accepts?('bbbabb')
=> true
irb.txt.tx(main):164:0> exit
irb.txt.tx(main):001:0> rulebook = NFARulebook.new([
irb.txt.tx(main):002:2*         FARule.new(0, '(', 1), FARule.new(1, ')', 0),
irb.txt.tx(main):003:2*         FARule.new(1, '(', 2), FARule.new(2, ')', 1),
irb.txt.tx(main):004:2*         FARule.new(2, '(', 3), FARule.new(3, ')', 2)
irb.txt.tx(main):005:2>     ])
just_add_power/irb.txt.tx:1:in `<main>': uninitialized constant NFARulebook (NameError)
Did you mean?  NPDARulebook
               DPDARulebook
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):006:0> nfa_design = NFADesign.new(0, [0], rulebook)
just_add_power/irb.txt.tx:6:in `<main>': uninitialized constant NFADesign (NameError)
Did you mean?  NPDADesign
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):007:0> nfa_design.accepts?('(()')
just_add_power/irb.txt.tx:7:in `<main>': undefined method `accepts?' for nil:NilClass (NoMethodError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):008:0> nfa_design.accepts?('())')
just_add_power/irb.txt.tx:8:in `<main>': undefined method `accepts?' for nil:NilClass (NoMethodError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):009:0> nfa_design.accepts?('(())')
just_add_power/irb.txt.tx:9:in `<main>': undefined method `accepts?' for nil:NilClass (NoMethodError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):010:0> nfa_design.accepts?('(()(()()))')
just_add_power/irb.txt.tx:10:in `<main>': undefined method `accepts?' for nil:NilClass (NoMethodError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):011:0> nfa_design.accepts?('(((())))')
just_add_power/irb.txt.tx:11:in `<main>': undefined method `accepts?' for nil:NilClass (NoMethodError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):012:0>
irb.txt.tx(main):013:0> balanced =
irb.txt.tx(main):014:0*     /
irb.txt.tx(main):015:0/     \A              # match beginning of string
irb.txt.tx(main):016:0/     (?<brackets>    # begin subexpression called "brackets"
irb.txt.tx(main):017:0/       \(            # match a literal opening bracket
irb.txt.tx(main):018:0/       \g<brackets>* # match "brackets" subexpression zero or more times
irb.txt.tx(main):019:0/       \)            # match a literal closing bracket
irb.txt.tx(main):020:0/     )               # end subexpression
irb.txt.tx(main):021:0/     *               # repeat the whole pattern zero or more times
irb.txt.tx(main):022:0/     \z              # match end of string
irb.txt.tx(main):023:0/   /x
=>
/
...
irb.txt.tx(main):024:0> ['(()', '())', '(())', '(()(()()))', '((((((((((()))))))))))'].grep(balanced)
=> ["(())", "(()(()()))", "((((((((((()))))))))))"]
irb.txt.tx(main):025:0>
irb.txt.tx(main):026:0> stack = Stack.new(['a', 'b', 'c', 'd', 'e'])
=> #<struct Stack contents=["a", "b", "c", "d", "e"]>
irb.txt.tx(main):027:0> stack.top
=> "a"
irb.txt.tx(main):028:0> stack.pop.pop.top
=> "c"
irb.txt.tx(main):029:0> stack.push('x').push('y').top
=> "y"
irb.txt.tx(main):030:0> stack.push('x').push('y').pop.top
=> "x"
irb.txt.tx(main):031:0>
irb.txt.tx(main):032:0> rule = PDARule.new(1, '(', 2, '$', ['b', '$'])
=> #<struct PDARule state=1, character="(", next_state=2, pop_character="$"...
irb.txt.tx(main):033:0> configuration = PDAConfiguration.new(1, Stack.new(['$']))
=> #<struct PDAConfiguration state=1, stack=#<struct Stack contents=["$"]>>
irb.txt.tx(main):034:0> rule.applies_to?(configuration, '(')
=> true
irb.txt.tx(main):035:0>
irb.txt.tx(main):036:0> stack = Stack.new(['$']).push('x').push('y').push('z')
=> #<struct Stack contents=["z", "y", "x", "$"]>
irb.txt.tx(main):037:0> stack.top
=> "z"
irb.txt.tx(main):038:0> stack = stack.pop; stack.top
=> "y"
irb.txt.tx(main):039:0> stack = stack.pop; stack.top
=> "x"
irb.txt.tx(main):040:0> rule.follow(configuration)
=> #<struct PDAConfiguration state=2, stack=#<struct Stack contents=["b", "$"]>>
irb.txt.tx(main):041:0>
irb.txt.tx(main):042:0> rulebook = DPDARulebook.new([
irb.txt.tx(main):043:2*         PDARule.new(1, '(', 2, '$', ['b', '$']),
irb.txt.tx(main):044:2*         PDARule.new(2, '(', 2, 'b', ['b', 'b']),
irb.txt.tx(main):045:2*         PDARule.new(2, ')', 2, 'b', []),
irb.txt.tx(main):046:2*         PDARule.new(2, nil, 1, '$', ['$'])
irb.txt.tx(main):047:2>     ])
=>
#<struct DPDARulebook
...
irb.txt.tx(main):048:0> configuration = rulebook.next_configuration(configuration, '(')
=> #<struct PDAConfiguration state=2, stack=#<struct Stack contents=["b", "...
irb.txt.tx(main):049:0> configuration = rulebook.next_configuration(configuration, '(')
=> #<struct PDAConfiguration state=2, stack=#<struct Stack contents=["b", "...
irb.txt.tx(main):050:0> configuration = rulebook.next_configuration(configuration, ')')
=> #<struct PDAConfiguration state=2, stack=#<struct Stack contents=["b", "...
irb.txt.tx(main):051:0>
irb.txt.tx(main):052:0> dpda = DPDA.new(PDAConfiguration.new(1, Stack.new(['$'])), [1], rulebook)
=>
#<struct DPDA
...
irb.txt.tx(main):053:0> dpda.accepting?
=> true
irb.txt.tx(main):054:0> dpda.read_string('(()'); dpda.accepting?
=> false
irb.txt.tx(main):055:0> dpda.current_configuration
=> #<struct PDAConfiguration state=2, stack=#<struct Stack contents=["b", "$"]>>
irb.txt.tx(main):056:0>
irb.txt.tx(main):057:0> configuration = PDAConfiguration.new(2, Stack.new(['$']))
=> #<struct PDAConfiguration state=2, stack=#<struct Stack contents=["$"]>>
irb.txt.tx(main):058:0> rulebook.follow_free_moves(configuration)
=> #<struct PDAConfiguration state=1, stack=#<struct Stack contents=["$"]>>
irb.txt.tx(main):059:0> DPDARulebook.new([PDARule.new(1, nil, 1, '$', ['$'])]).
irb.txt.tx(main):060:0>   follow_free_moves(PDAConfiguration.new(1, Stack.new(['$'])))
/home/yj/gnusrc/computationbook/just_add_power/stack.rb:3:in `push': stack level too deep (SystemStackError)
        from /home/yj/gnusrc/computationbook/just_add_power/pda_rule.rb:17:in `block in next_stack'
        from /home/yj/gnusrc/computationbook/just_add_power/pda_rule.rb:17:in `each'
        from /home/yj/gnusrc/computationbook/just_add_power/pda_rule.rb:17:in `inject'
        from /home/yj/gnusrc/computationbook/just_add_power/pda_rule.rb:17:in `next_stack'
        from /home/yj/gnusrc/computationbook/just_add_power/pda_rule.rb:10:in `follow'
        from /home/yj/gnusrc/computationbook/just_add_power/dpda_rulebook.rb:3:in `next_configuration'
        from /home/yj/gnusrc/computationbook/just_add_power/dpda_rulebook.rb:16:in `follow_free_moves'
        from /home/yj/gnusrc/computationbook/just_add_power/dpda_rulebook.rb:16:in `follow_free_moves'
         ... 10905 levels...
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        from /usr/bin/bundle:25:in `load'
        from /usr/bin/bundle:25:in `<main>'
irb.txt.tx(main):061:0>
irb.txt.tx(main):062:0> dpda = DPDA.new(PDAConfiguration.new(1, Stack.new(['$'])), [1], rulebook)
=>
#<struct DPDA
...
irb.txt.tx(main):063:0> dpda.read_string('(()('); dpda.accepting?
=> false
irb.txt.tx(main):064:0> dpda.current_configuration
=> #<struct PDAConfiguration state=2, stack=#<struct Stack contents=["b", "b", "$"]>>
irb.txt.tx(main):065:0> dpda.read_string('))()'); dpda.accepting?
=> true
irb.txt.tx(main):066:0> dpda.current_configuration
=> #<struct PDAConfiguration state=1, stack=#<struct Stack contents=["$"]>>
irb.txt.tx(main):067:0>
irb.txt.tx(main):068:0> dpda_design = DPDADesign.new(1, '$', [1], rulebook)
=>
#<struct DPDADesign
...
irb.txt.tx(main):069:0> dpda_design.accepts?('(((((((((())))))))))')
=> true
irb.txt.tx(main):070:0> dpda_design.accepts?('()(())((()))(()(()))')
=> true
irb.txt.tx(main):071:0> dpda_design.accepts?('(()(()(()()(()()))()')
=> false
irb.txt.tx(main):072:0> dpda_design.accepts?('())')
=> false
irb.txt.tx(main):073:0>
irb.txt.tx(main):074:0> dpda = DPDA.new(PDAConfiguration.new(1, Stack.new(['$'])), [1], rulebook)
=>
#<struct DPDA
...
irb.txt.tx(main):075:0> dpda.read_string('())'); dpda.current_configuration
=> #<struct PDAConfiguration state=#<Object:0x0000555d1eb010a0>, stack=#<struct Stack contents=["$"]>>
irb.txt.tx(main):076:0> dpda.accepting?
=> false
irb.txt.tx(main):077:0> dpda.stuck?
=> true
irb.txt.tx(main):078:0> dpda_design.accepts?('())')
=> false
irb.txt.tx(main):079:0> rulebook = DPDARulebook.new([
irb.txt.tx(main):080:2*         PDARule.new(1, 'a', 2, '$', ['a', '$']),
irb.txt.tx(main):081:2*         PDARule.new(1, 'b', 2, '$', ['b', '$']),
irb.txt.tx(main):082:2*         PDARule.new(2, 'a', 2, 'a', ['a', 'a']),
irb.txt.tx(main):083:2*         PDARule.new(2, 'b', 2, 'b', ['b', 'b']),
irb.txt.tx(main):084:2*         PDARule.new(2, 'a', 2, 'b', []),
irb.txt.tx(main):085:2*         PDARule.new(2, 'b', 2, 'a', []),
irb.txt.tx(main):086:2*         PDARule.new(2, nil, 1, '$', ['$'])
irb.txt.tx(main):087:2>     ])
=>
#<struct DPDARulebook
...
irb.txt.tx(main):088:0> dpda_design = DPDADesign.new(1, '$', [1], rulebook)
=>
#<struct DPDADesign
...
irb.txt.tx(main):089:0> dpda_design.accepts?('ababab')
=> true
irb.txt.tx(main):090:0> dpda_design.accepts?('bbbaaaab')
=> true
irb.txt.tx(main):091:0> dpda_design.accepts?('baa')
=> false
irb.txt.tx(main):092:0> rulebook = DPDARulebook.new([
irb.txt.tx(main):093:2*         PDARule.new(1, 'a', 1, '$', ['a', '$']),
irb.txt.tx(main):094:2*         PDARule.new(1, 'a', 1, 'a', ['a', 'a']),
irb.txt.tx(main):095:2*         PDARule.new(1, 'a', 1, 'b', ['a', 'b']),
irb.txt.tx(main):096:2*         PDARule.new(1, 'b', 1, '$', ['b', '$']),
irb.txt.tx(main):097:2*         PDARule.new(1, 'b', 1, 'a', ['b', 'a']),
irb.txt.tx(main):098:2*         PDARule.new(1, 'b', 1, 'b', ['b', 'b']),
irb.txt.tx(main):099:2*         PDARule.new(1, 'm', 2, '$', ['$']),
irb.txt.tx(main):100:2*         PDARule.new(1, 'm', 2, 'a', ['a']),
irb.txt.tx(main):101:2*         PDARule.new(1, 'm', 2, 'b', ['b']),
irb.txt.tx(main):102:2*         PDARule.new(2, 'a', 2, 'a', []),
irb.txt.tx(main):103:2*         PDARule.new(2, 'b', 2, 'b', []),
irb.txt.tx(main):104:2*         PDARule.new(2, nil, 3, '$', ['$'])
irb.txt.tx(main):105:2>     ])
=>
#<struct DPDARulebook
...
irb.txt.tx(main):106:0> dpda_design = DPDADesign.new(1, '$', [3], rulebook)
=>
#<struct DPDADesign
...
irb.txt.tx(main):107:0> dpda_design.accepts?('abmba')
=> true
irb.txt.tx(main):108:0> dpda_design.accepts?('babbamabbab')
=> true
irb.txt.tx(main):109:0> dpda_design.accepts?('abmb')
=> false
irb.txt.tx(main):110:0> dpda_design.accepts?('baambaa')
=> false
irb.txt.tx(main):111:0>
irb.txt.tx(main):112:0> rulebook = NPDARulebook.new([
irb.txt.tx(main):113:2*         PDARule.new(1, 'a', 1, '$', ['a', '$']),
irb.txt.tx(main):114:2*         PDARule.new(1, 'a', 1, 'a', ['a', 'a']),
irb.txt.tx(main):115:2*         PDARule.new(1, 'a', 1, 'b', ['a', 'b']),
irb.txt.tx(main):116:2*         PDARule.new(1, 'b', 1, '$', ['b', '$']),
irb.txt.tx(main):117:2*         PDARule.new(1, 'b', 1, 'a', ['b', 'a']),
irb.txt.tx(main):118:2*         PDARule.new(1, 'b', 1, 'b', ['b', 'b']),
irb.txt.tx(main):119:2*         PDARule.new(1, nil, 2, '$', ['$']),
irb.txt.tx(main):120:2*         PDARule.new(1, nil, 2, 'a', ['a']),
irb.txt.tx(main):121:2*         PDARule.new(1, nil, 2, 'b', ['b']),
irb.txt.tx(main):122:2*         PDARule.new(2, 'a', 2, 'a', []),
irb.txt.tx(main):123:2*         PDARule.new(2, 'b', 2, 'b', []),
irb.txt.tx(main):124:2*         PDARule.new(2, nil, 3, '$', ['$'])
irb.txt.tx(main):125:2>     ])
=>
#<struct NPDARulebook
...
irb.txt.tx(main):126:0> configuration = PDAConfiguration.new(1, Stack.new(['$']))
=> #<struct PDAConfiguration state=1, stack=#<struct Stack contents=["$"]>>
irb.txt.tx(main):127:0> npda = NPDA.new(Set[configuration], [3], rulebook)
=>
#<struct NPDA
...
irb.txt.tx(main):128:0> npda.accepting?
=> true
irb.txt.tx(main):129:0> npda.current_configurations
=>
#<Set: {#<struct PDAConfiguration state=1, stack=#<struct Stack contents=["$"]>>,
 #<struct PDAConfiguration state=2, stack=#<struct Stack contents=["$"]>>,
 #<struct PDAConfiguration state=3, stack=#<struct Stack contents=["$"]>>}>
irb.txt.tx(main):130:0> npda.read_string('abb'); npda.accepting?
=> false
irb.txt.tx(main):131:0> npda.current_configurations
=>
#<Set: {#<struct PDAConfiguration state=1, stack=#<struct Stack contents=["b", "b", "a", "$"]>>,
 #<struct PDAConfiguration state=2, stack=#<struct Stack contents=["a", "$"]>>,
 #<struct PDAConfiguration state=2, stack=#<struct Stack contents=["b", "b", "a", "$"]>>}>
irb.txt.tx(main):132:0> npda.read_character('a'); npda.accepting?
=> true
irb.txt.tx(main):133:0> npda.current_configurations
=>
#<Set: {#<struct PDAConfiguration state=1, stack=#<struct Stack contents=["a", "b", "b", "a", "$"]>>,
 #<struct PDAConfiguration state=2, stack=#<struct Stack contents=["$"]>>,
 #<struct PDAConfiguration state=2, stack=#<struct Stack contents=["a", "b", "b", "a", "$"]>>,
 #<struct PDAConfiguration state=3, stack=#<struct Stack contents=["$"]>>}>
irb.txt.tx(main):134:0>
irb.txt.tx(main):135:0> npda_design = NPDADesign.new(1, '$', [3], rulebook)
=>
#<struct NPDADesign
...
irb.txt.tx(main):136:0> npda_design.accepts?('abba')
=> true
irb.txt.tx(main):137:0> npda_design.accepts?('babbaabbab')
=> true
irb.txt.tx(main):138:0> npda_design.accepts?('abb')
=> false
irb.txt.tx(main):139:0> npda_design.accepts?('baabaa')
=> false
irb.txt.tx(main):140:0>
irb.txt.tx(main):141:0> LexicalAnalyzer.new('y = x * 7').analyze
=> ["v", "=", "v", "*", "n"]
irb.txt.tx(main):142:0> LexicalAnalyzer.new('while (x < 5) { x = x * 3 }').analyze
=> ["w", "(", "v", "<", "n", ")", "{", "v", "=", "v", "*", "n", "}"]
irb.txt.tx(main):143:0> LexicalAnalyzer.new('if (x < 10) { y = true; x = 0 } else { do-nothing }').analyze
=> ["i", "(", "v", "<", "n", ")", "{", "v", "=", "b", ";", "v", "=", "n", "}", "e", "{", "d", "}"]
irb.txt.tx(main):144:0> LexicalAnalyzer.new('x = false').analyze
=> ["v", "=", "b"]
irb.txt.tx(main):145:0> LexicalAnalyzer.new('x = falsehood').analyze
=> ["v", "=", "v"]
irb.txt.tx(main):146:0> start_rule = PDARule.new(1, nil, 2, '$', ['S', '$'])
=> #<struct PDARule state=1, character=nil, next_state=2, pop_character="$"...
irb.txt.tx(main):147:0> symbol_rules =
irb.txt.tx(main):148:0*     [
irb.txt.tx(main):149:1*         # <statement> ::= <while> | <assign>
irb.txt.tx(main):150:1*         PDARule.new(2, nil, 2, 'S', ['W']),
irb.txt.tx(main):151:1*         PDARule.new(2, nil, 2, 'S', ['A']),
irb.txt.tx(main):152:1*
irb.txt.tx(main):153:1*         # <while> ::= 'w' '(' <expression> ')' '{' <statement> '}'
irb.txt.tx(main):154:1*         PDARule.new(2, nil, 2, 'W', ['w', '(', 'E', ')', '{', 'S', '}']),
irb.txt.tx(main):155:1*
irb.txt.tx(main):156:1*         # <assign> ::= 'v' '=' <expression>
irb.txt.tx(main):157:1*         PDARule.new(2, nil, 2, 'A', ['v', '=', 'E']),
irb.txt.tx(main):158:1*
irb.txt.tx(main):159:1*         # <expression> ::= <less-than>
irb.txt.tx(main):160:1*         PDARule.new(2, nil, 2, 'E', ['L']),
irb.txt.tx(main):161:1*
irb.txt.tx(main):162:1*         # <less-than> ::= <multiply> '<' <less-than> | <multiply>
irb.txt.tx(main):163:1*         PDARule.new(2, nil, 2, 'L', ['M', '<', 'L']),
irb.txt.tx(main):164:1*         PDARule.new(2, nil, 2, 'L', ['M']),
irb.txt.tx(main):165:1*
irb.txt.tx(main):166:1*         # <multiply> ::= <term> '*' <multiply> | <term>
irb.txt.tx(main):167:1*         PDARule.new(2, nil, 2, 'M', ['T', '*', 'M']),
irb.txt.tx(main):168:1*         PDARule.new(2, nil, 2, 'M', ['T']),
irb.txt.tx(main):169:1*
irb.txt.tx(main):170:1*         # <term> ::= 'n' | 'v'
irb.txt.tx(main):171:1*         PDARule.new(2, nil, 2, 'T', ['n']),
irb.txt.tx(main):172:1*         PDARule.new(2, nil, 2, 'T', ['v'])
irb.txt.tx(main):173:1>     ]
=> [#<struct PDARule state=2, character=nil, next_state=2, pop_character="S...
irb.txt.tx(main):174:0> token_rules =
irb.txt.tx(main):175:0*     LexicalAnalyzer::GRAMMAR.map do |rule|
irb.txt.tx(main):176:1*         PDARule.new(2, rule[:token], 2, rule[:token], [])
irb.txt.tx(main):177:1>     end
=> [#<struct PDARule state=2, character="i", next_state=2, pop_character="i...
irb.txt.tx(main):178:0> stop_rule = PDARule.new(2, nil, 3, '$', ['$'])
=> #<struct PDARule state=2, character=nil, next_state=3, pop_character="$"...
irb.txt.tx(main):179:0> rulebook = NPDARulebook.new([start_rule, stop_rule] + symbol_rules + token_rules)
=>
#<struct NPDARulebook
...
irb.txt.tx(main):180:0> npda_design = NPDADesign.new(1, '$', [3], rulebook)
=>
#<struct NPDADesign
...
irb.txt.tx(main):181:0> token_string = LexicalAnalyzer.new('while (x < 5) { x = x * 3 }').analyze.join
=> "w(v<n){v=v*n}"
irb.txt.tx(main):182:0> npda_design.accepts?(token_string)
=> true
irb.txt.tx(main):183:0> npda_design.accepts?(LexicalAnalyzer.new('while (x < 5 x = x * }').analyze.join)
=> false
irb.txt.tx(main):184:0> exit
irb.txt.tx(main):001:0> tape = Tape.new(['1', '0', '1'], '1', [], '_')
=> #<struct Tape left=["1", "0", "1"], middle="1", right=[], blank="_">
irb.txt.tx(main):002:0> tape.middle
=> "1"
irb.txt.tx(main):003:0>
irb.txt.tx(main):004:0> tape
=> #<struct Tape left=["1", "0", "1"], middle="1", right=[], blank="_">
irb.txt.tx(main):005:0> tape.move_head_left
=> #<struct Tape left=["1", "0"], middle="1", right=["1"], blank="_">
irb.txt.tx(main):006:0> tape.write('0')
=> #<struct Tape left=["1", "0", "1"], middle="0", right=[], blank="_">
irb.txt.tx(main):007:0> tape.move_head_right
=> #<struct Tape left=["1", "0", "1", "1"], middle="_", right=[], blank="_">
irb.txt.tx(main):008:0> tape.move_head_right.write('0')
=> #<struct Tape left=["1", "0", "1", "1"], middle="0", right=[], blank="_">
irb.txt.tx(main):009:0>
irb.txt.tx(main):010:0> rule = TMRule.new(1, '0', 2, '1', :right)
=> #<struct TMRule state=1, character="0", next_state=2, write_character="1...
irb.txt.tx(main):011:0> rule.applies_to?(TMConfiguration.new(1, Tape.new([], '0', [], '_')))
=> true
irb.txt.tx(main):012:0> rule.applies_to?(TMConfiguration.new(1, Tape.new([], '1', [], '_')))
=> false
irb.txt.tx(main):013:0> rule.applies_to?(TMConfiguration.new(2, Tape.new([], '0', [], '_')))
=> false
irb.txt.tx(main):014:0>
irb.txt.tx(main):015:0> rule.follow(TMConfiguration.new(1, Tape.new([], '0', [], '_')))
=> #<struct TMConfiguration state=2, tape=#<struct Tape left=["1"], middle="_", right=[], blank="_">>
irb.txt.tx(main):016:0>
irb.txt.tx(main):017:0> rulebook = DTMRulebook.new([
irb.txt.tx(main):018:2*         TMRule.new(1, '0', 2, '1', :right),
irb.txt.tx(main):019:2*         TMRule.new(1, '1', 1, '0', :left),
irb.txt.tx(main):020:2*         TMRule.new(1, '_', 2, '1', :right),
irb.txt.tx(main):021:2*         TMRule.new(2, '0', 2, '0', :right),
irb.txt.tx(main):022:2*         TMRule.new(2, '1', 2, '1', :right),
irb.txt.tx(main):023:2*         TMRule.new(2, '_', 3, '_', :left)
irb.txt.tx(main):024:2>     ])
=>
#<struct DTMRulebook
...
irb.txt.tx(main):025:0> configuration = TMConfiguration.new(1, tape)
=> #<struct TMConfiguration state=1, tape=#<struct Tape left=["1", "0", "1"...
irb.txt.tx(main):026:0> configuration = rulebook.next_configuration(configuration)
=> #<struct TMConfiguration state=1, tape=#<struct Tape left=["1", "0"], mi...
irb.txt.tx(main):027:0> configuration = rulebook.next_configuration(configuration)
=> #<struct TMConfiguration state=1, tape=#<struct Tape left=["1"], middle=...
irb.txt.tx(main):028:0> configuration = rulebook.next_configuration(configuration)
=> #<struct TMConfiguration state=2, tape=#<struct Tape left=["1", "1"], mi...
irb.txt.tx(main):029:0>
irb.txt.tx(main):030:0> dtm = DTM.new(TMConfiguration.new(1, tape), [3], rulebook)
=>
#<struct DTM
...
irb.txt.tx(main):031:0> dtm.current_configuration
=> #<struct TMConfiguration state=1, tape=#<struct Tape left=["1", "0", "1"], middle="1", right=[], blank="_">>
irb.txt.tx(main):032:0> dtm.accepting?
=> false
irb.txt.tx(main):033:0> dtm.step; dtm.current_configuration
=> #<struct TMConfiguration state=1, tape=#<struct Tape left=["1", "0"], middle="1", right=["0"], blank="_">>
irb.txt.tx(main):034:0> dtm.accepting?
=> false
irb.txt.tx(main):035:0> dtm.run
=> nil
irb.txt.tx(main):036:0> dtm.current_configuration
=> #<struct TMConfiguration state=3, tape=#<struct Tape left=["1", "1", "0"], middle="0", right=["_"], blank="_">>
irb.txt.tx(main):037:0> dtm.accepting?
=> true
irb.txt.tx(main):038:0> tape = Tape.new(['1', '2', '1'], '1', [], '_')
=> #<struct Tape left=["1", "2", "1"], middle="1", right=[], blank="_">
irb.txt.tx(main):039:0> dtm = DTM.new(TMConfiguration.new(1, tape), [3], rulebook)
=>
#<struct DTM
...
irb.txt.tx(main):040:0> dtm.run
=> nil
irb.txt.tx(main):041:0>
irb.txt.tx(main):042:0> dtm = DTM.new(TMConfiguration.new(1, tape), [3], rulebook)
=>
#<struct DTM
...
irb.txt.tx(main):043:0> dtm.run
=> nil
irb.txt.tx(main):044:0> dtm.current_configuration
=> #<struct TMConfiguration state=1, tape=#<struct Tape left=["1"], middle="2", right=["0", "0"], blank="_">>
irb.txt.tx(main):045:0> dtm.accepting?
=> false
irb.txt.tx(main):046:0> dtm.stuck?
=> true
irb.txt.tx(main):047:0> rulebook = DTMRulebook.new([
irb.txt.tx(main):048:2*         # state 1: scan right looking for a
irb.txt.tx(main):049:2*         TMRule.new(1, 'X', 1, 'X', :right), # skip X
irb.txt.tx(main):050:2*         TMRule.new(1, 'a', 2, 'X', :right), # cross out a, go to state 2
irb.txt.tx(main):051:2*         TMRule.new(1, '_', 6, '_', :left),  # find blank, go to state 6 (accept)
irb.txt.tx(main):052:2*
irb.txt.tx(main):053:2*         # state 2: scan right looking for b
irb.txt.tx(main):054:2*         TMRule.new(2, 'a', 2, 'a', :right), # skip a
irb.txt.tx(main):055:2*         TMRule.new(2, 'X', 2, 'X', :right), # skip X
irb.txt.tx(main):056:2*         TMRule.new(2, 'b', 3, 'X', :right), # cross out b, go to state 3
irb.txt.tx(main):057:2*
irb.txt.tx(main):058:2*         # state 3: scan right looking for c
irb.txt.tx(main):059:2*         TMRule.new(3, 'b', 3, 'b', :right), # skip b
irb.txt.tx(main):060:2*         TMRule.new(3, 'X', 3, 'X', :right), # skip X
irb.txt.tx(main):061:2*         TMRule.new(3, 'c', 4, 'X', :right), # cross out c, go to state 4
irb.txt.tx(main):062:2*
irb.txt.tx(main):063:2*         # state 4: scan right looking for end of string
irb.txt.tx(main):064:2*         TMRule.new(4, 'c', 4, 'c', :right), # skip c
irb.txt.tx(main):065:2*         TMRule.new(4, '_', 5, '_', :left),  # find blank, go to state 5
irb.txt.tx(main):066:2*
irb.txt.tx(main):067:2*         # state 5: scan left looking for beginning of string
irb.txt.tx(main):068:2*         TMRule.new(5, 'a', 5, 'a', :left),  # skip a
irb.txt.tx(main):069:2*         TMRule.new(5, 'b', 5, 'b', :left),  # skip b
irb.txt.tx(main):070:2*         TMRule.new(5, 'c', 5, 'c', :left),  # skip c
irb.txt.tx(main):071:2*         TMRule.new(5, 'X', 5, 'X', :left),  # skip X
irb.txt.tx(main):072:2*         TMRule.new(5, '_', 1, '_', :right)  # find blank, go to state 1
irb.txt.tx(main):073:2>     ])
=>
#<struct DTMRulebook
...
irb.txt.tx(main):074:0> tape = Tape.new([], 'a', ['a', 'a', 'b', 'b', 'b', 'c', 'c', 'c'], '_')
=> #<struct Tape left=[], middle="a", right=["a", "a", "b", "b", "b", "c", ...
irb.txt.tx(main):075:0> dtm = DTM.new(TMConfiguration.new(1, tape), [6], rulebook)
=>
#<struct DTM
...
irb.txt.tx(main):076:0> 10.times { dtm.step }; dtm.current_configuration
=> #<struct TMConfiguration state=5, tape=#<struct Tape left=["X", "a", "a", "X", "b", "b", "X", "c"], middle="c", right=["_"], blank="_">>
irb.txt.tx(main):077:0> 25.times { dtm.step }; dtm.current_configuration
=> #<struct TMConfiguration state=5, tape=#<struct Tape left=["_", "X", "X", "a"], middle="X", right=["X", "b", "X", "X", "c", "_"], blank="_">>
irb.txt.tx(main):078:0> dtm.run; dtm.current_configuration
=> #<struct TMConfiguration state=6, tape=#<struct Tape left=["_", "X", "X", "X", "X", "X", "X", "X", "X"], middle="X", right=["_"], blank="_">>
irb.txt.tx(main):079:0> rulebook = DTMRulebook.new([
irb.txt.tx(main):080:2*         # state 1: read the first character from the tape
irb.txt.tx(main):081:2*         TMRule.new(1, 'a', 2, 'a', :right), # remember a
irb.txt.tx(main):082:2*         TMRule.new(1, 'b', 3, 'b', :right), # remember b
irb.txt.tx(main):083:2*         TMRule.new(1, 'c', 4, 'c', :right), # remember c
irb.txt.tx(main):084:2*
irb.txt.tx(main):085:2*         # state 2: scan right looking for end of string (remembering a)
irb.txt.tx(main):086:2*         TMRule.new(2, 'a', 2, 'a', :right), # skip a
irb.txt.tx(main):087:2*         TMRule.new(2, 'b', 2, 'b', :right), # skip b
irb.txt.tx(main):088:2*         TMRule.new(2, 'c', 2, 'c', :right), # skip c
irb.txt.tx(main):089:2*         TMRule.new(2, '_', 5, 'a', :right), # find blank, write a
irb.txt.tx(main):090:2*
irb.txt.tx(main):091:2*         # state 3: scan right looking for end of string (remembering b)
irb.txt.tx(main):092:2*         TMRule.new(3, 'a', 3, 'a', :right), # skip a
irb.txt.tx(main):093:2*         TMRule.new(3, 'b', 3, 'b', :right), # skip b
irb.txt.tx(main):094:2*         TMRule.new(3, 'c', 3, 'c', :right), # skip c
irb.txt.tx(main):095:2*         TMRule.new(3, '_', 5, 'b', :right), # find blank, write b
irb.txt.tx(main):096:2*
irb.txt.tx(main):097:2*         # state 4: scan right looking for end of string (remembering c)
irb.txt.tx(main):098:2*         TMRule.new(4, 'a', 4, 'a', :right), # skip a
irb.txt.tx(main):099:2*         TMRule.new(4, 'b', 4, 'b', :right), # skip b
irb.txt.tx(main):100:2*         TMRule.new(4, 'c', 4, 'c', :right), # skip c
irb.txt.tx(main):101:2*         TMRule.new(4, '_', 5, 'c', :right)  # find blank, write c
irb.txt.tx(main):102:2>     ])
=>
#<struct DTMRulebook
...
irb.txt.tx(main):103:0> tape = Tape.new([], 'b', ['c', 'b', 'c', 'a'], '_')
=> #<struct Tape left=[], middle="b", right=["c", "b", "c", "a"], blank="_">
irb.txt.tx(main):104:0> dtm = DTM.new(TMConfiguration.new(1, tape), [5], rulebook)
=>
#<struct DTM
...
irb.txt.tx(main):105:0> dtm.run; dtm.current_configuration.tape
=> #<struct Tape left=["b", "c", "b", "c", "a", "b"], middle="_", right=[], blank="_">
irb.txt.tx(main):106:0>
irb.txt.tx(main):107:0> def increment_rules(start_state, return_state)
irb.txt.tx(main):108:1>     incrementing = start_state
irb.txt.tx(main):109:1>     finishing = Object.new
irb.txt.tx(main):110:1>     finished = return_state
irb.txt.tx(main):111:1>
irb.txt.tx(main):112:1>     [
irb.txt.tx(main):113:2*           TMRule.new(incrementing, '0', finishing,    '1', :right),
irb.txt.tx(main):114:2*           TMRule.new(incrementing, '1', incrementing, '0', :left),
irb.txt.tx(main):115:2*           TMRule.new(incrementing, '_', finishing,    '1', :right),
irb.txt.tx(main):116:2*           TMRule.new(finishing,    '0', finishing,    '0', :right),
irb.txt.tx(main):117:2*           TMRule.new(finishing,    '1', finishing,    '1', :right),
irb.txt.tx(main):118:2*           TMRule.new(finishing,    '_', finished,     '_', :left)
irb.txt.tx(main):119:2>       ]
irb.txt.tx(main):120:1>   end
=> :increment_rules
irb.txt.tx(main):121:0>
irb.txt.tx(main):122:0> added_zero, added_one, added_two, added_three = 0, 1, 2, 3
=> [0, 1, 2, 3]
irb.txt.tx(main):123:0> rulebook = DTMRulebook.new(
irb.txt.tx(main):124:1*       increment_rules(added_zero, added_one) +
irb.txt.tx(main):125:1*       increment_rules(added_one, added_two) +
irb.txt.tx(main):126:1*       increment_rules(added_two, added_three)
irb.txt.tx(main):127:1>   )
=>
#<struct DTMRulebook
...
irb.txt.tx(main):128:0> rulebook.rules.length
=> 18
irb.txt.tx(main):129:0> tape = Tape.new(['1', '0', '1'], '1', [], '_')
=> #<struct Tape left=["1", "0", "1"], middle="1", right=[], blank="_">
irb.txt.tx(main):130:0> dtm = DTM.new(TMConfiguration.new(added_zero, tape), [added_three], rulebook)
=>
#<struct DTM
...
irb.txt.tx(main):131:0> dtm.run; dtm.current_configuration.tape
=> #<struct Tape left=["1", "1", "1"], middle="0", right=["_"], blank="_">
irb.txt.tx(main):132:0> exit
irb.txt.tx(main):001:0> -> x { -> y { x.call(y) } }
=> #<Proc:0x000055cad06ada60 programming_with_nothing/irb.txt.tx:1 (lambda)>
irb.txt.tx(main):002:0> -> x { x + 2 }.call(1)
=> 3
irb.txt.tx(main):003:0> -> x, y {
irb.txt.tx(main):004:1*       x + y
irb.txt.tx(main):005:1>   }.call(3, 4)
=> 7
irb.txt.tx(main):006:0> -> x {
irb.txt.tx(main):007:1*       -> y {
irb.txt.tx(main):008:2*           x + y
irb.txt.tx(main):009:2>       }
irb.txt.tx(main):010:1>   }.call(3).call(4)
=> 7
irb.txt.tx(main):011:0> p = -> n { n * 2 }
=> #<Proc:0x000055cad06fcf70 programming_with_nothing/irb.txt.tx:11 (lambda)>
irb.txt.tx(main):012:0> q = -> x { p.call(x) }
=> #<Proc:0x000055cad070cf88 programming_with_nothing/irb.txt.tx:12 (lambda)>
irb.txt.tx(main):013:0> p.call(5)
=> 10
irb.txt.tx(main):014:0> q.call(5)
=> 10
irb.txt.tx(main):015:0> -> x { x + 5 }[6]
=> 11
irb.txt.tx(main):016:0> (1..100).each do |n|
irb.txt.tx(main):017:1*       if (n % 15).zero?
irb.txt.tx(main):018:2>         puts 'FizzBuzz'
irb.txt.tx(main):019:2>       elsif (n % 3).zero?
irb.txt.tx(main):020:2>         puts 'Fizz'
irb.txt.tx(main):021:2>       elsif (n % 5).zero?
irb.txt.tx(main):022:2>         puts 'Buzz'
irb.txt.tx(main):023:2>       else
irb.txt.tx(main):024:2>         puts n.to_s
irb.txt.tx(main):025:2>       end
irb.txt.tx(main):026:1>   end
1
2
Fizz
4
Buzz
Fizz
7
8
Fizz
Buzz
11
Fizz
13
14
FizzBuzz
16
17
Fizz
19
Buzz
Fizz
22
23
Fizz
Buzz
26
Fizz
28
29
FizzBuzz
31
32
Fizz
34
Buzz
Fizz
37
38
Fizz
Buzz
41
Fizz
43
44
FizzBuzz
46
47
Fizz
49
Buzz
Fizz
52
53
Fizz
Buzz
56
Fizz
58
59
FizzBuzz
61
62
Fizz
64
Buzz
Fizz
67
68
Fizz
Buzz
71
Fizz
73
74
FizzBuzz
76
77
Fizz
79
Buzz
Fizz
82
83
Fizz
Buzz
86
Fizz
88
89
FizzBuzz
91
92
Fizz
94
Buzz
Fizz
97
98
Fizz
Buzz
=> 1..100
irb.txt.tx(main):027:0> (1..100).map do |n|
irb.txt.tx(main):028:1*       if (n % 15).zero?
irb.txt.tx(main):029:2>         'FizzBuzz'
irb.txt.tx(main):030:2>       elsif (n % 3).zero?
irb.txt.tx(main):031:2>         'Fizz'
irb.txt.tx(main):032:2>       elsif (n % 5).zero?
irb.txt.tx(main):033:2>         'Buzz'
irb.txt.tx(main):034:2>       else
irb.txt.tx(main):035:2>         n.to_s
irb.txt.tx(main):036:2>       end
irb.txt.tx(main):037:1>   end
=>
["1",
 "2",
 "Fizz",
 "4",
 "Buzz",
 "Fizz",
 "7",
 "8",
 "Fizz",
 "Buzz",
 "11",
 "Fizz",
 "13",
 "14",
 "FizzBuzz",
 "16",
 "17",
 "Fizz",
 "19",
 "Buzz",
 "Fizz",
 "22",
 "23",
 "Fizz",
 "Buzz",
 "26",
 "Fizz",
 "28",
 "29",
 "FizzBuzz",
 "31",
 "32",
 "Fizz",
 "34",
 "Buzz",
 "Fizz",
 "37",
 "38",
 "Fizz",
 "Buzz",
 "41",
 "Fizz",
 "43",
 "44",
 "FizzBuzz",
 "46",
 "47",
 "Fizz",
 "49",
 "Buzz",
 "Fizz",
 "52",
 "53",
 "Fizz",
 "Buzz",
 "56",
 "Fizz",
 "58",
 "59",
 "FizzBuzz",
 "61",
 "62",
 "Fizz",
 "64",
 "Buzz",
 "Fizz",
 "67",
 "68",
 "Fizz",
 "Buzz",
 "71",
 "Fizz",
 "73",
 "74",
 "FizzBuzz",
 "76",
 "77",
 "Fizz",
 "79",
 "Buzz",
 "Fizz",
 "82",
 "83",
 "Fizz",
 "Buzz",
 "86",
 "Fizz",
 "88",
 "89",
 "FizzBuzz",
 "91",
 "92",
 "Fizz",
 "94",
 "Buzz",
 "Fizz",
 "97",
 "98",
 "Fizz",
 "Buzz"]
irb.txt.tx(main):038:0>
irb.txt.tx(main):039:0> def one(proc, x)
irb.txt.tx(main):040:1>     proc[x]
irb.txt.tx(main):041:1>   end
=> :one
irb.txt.tx(main):042:0>
irb.txt.tx(main):043:0> def two(proc, x)
irb.txt.tx(main):044:1>     proc[proc[x]]
irb.txt.tx(main):045:1>   end
=> :two
irb.txt.tx(main):046:0>
irb.txt.tx(main):047:0> def three(proc, x)
irb.txt.tx(main):048:1>     proc[proc[proc[x]]]
irb.txt.tx(main):049:1>   end
=> :three
irb.txt.tx(main):050:0>
irb.txt.tx(main):051:0> def zero(proc, x)
irb.txt.tx(main):052:1>     x
irb.txt.tx(main):053:1>   end
=> :zero
irb.txt.tx(main):054:0>
irb.txt.tx(main):055:0> to_integer(ZERO)
=> 0
irb.txt.tx(main):056:0> to_integer(THREE)
=> 3
irb.txt.tx(main):057:0> to_integer(FIVE)
=> 5
irb.txt.tx(main):058:0> to_integer(FIFTEEN)
=> 15
irb.txt.tx(main):059:0> to_integer(HUNDRED)
=> 100
irb.txt.tx(main):060:0> success = true
=> true
irb.txt.tx(main):061:0> if success then 'happy' else 'sad' end
=> "happy"
irb.txt.tx(main):062:0> success = false
=> false
irb.txt.tx(main):063:0> if success then 'happy' else 'sad' end
=> "sad"
irb.txt.tx(main):064:0>
irb.txt.tx(main):065:0> def true(x, y)
irb.txt.tx(main):066:1>     x
irb.txt.tx(main):067:1>   end
=> :true
irb.txt.tx(main):068:0>
irb.txt.tx(main):069:0> def false(x, y)
irb.txt.tx(main):070:1>     y
irb.txt.tx(main):071:1>   end
=> :false
irb.txt.tx(main):072:0>
irb.txt.tx(main):073:0> success = :true
=> :true
irb.txt.tx(main):074:0> send(success, 'happy', 'sad')
=> "happy"
irb.txt.tx(main):075:0> success = :false
=> :false
irb.txt.tx(main):076:0> send(success, 'happy', 'sad')
=> "sad"
irb.txt.tx(main):077:0>
irb.txt.tx(main):078:0> def to_boolean(proc)
irb.txt.tx(main):079:1>     proc[true][false]
irb.txt.tx(main):080:1>   end
=> :to_boolean
irb.txt.tx(main):081:0>
irb.txt.tx(main):082:0> to_boolean(TRUE)
=> true
irb.txt.tx(main):083:0> to_boolean(FALSE)
=> false
irb.txt.tx(main):084:0>
irb.txt.tx(main):085:0> def if(proc, x, y)
irb.txt.tx(main):086:1>     proc[x][y]
irb.txt.tx(main):087:1>   end
=> :if
irb.txt.tx(main):088:0>
irb.txt.tx(main):089:0> IF =
irb.txt.tx(main):090:0*     -> b {
irb.txt.tx(main):091:1*         -> x {
irb.txt.tx(main):092:2*             -> y {
irb.txt.tx(main):093:3*                 b[x][y]
irb.txt.tx(main):094:3>             }
irb.txt.tx(main):095:2>         }
irb.txt.tx(main):096:1>     }
programming_with_nothing/irb.txt.tx:89: warning: already initialized constant IF
/home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:15: warning: previous definition of IF was here
=> #<Proc:0x000055cacfd1b740 programming_with_nothing/irb.txt.tx:90 (lambda)>
irb.txt.tx(main):097:0> IF[TRUE]['happy']['sad']
=> "happy"
irb.txt.tx(main):098:0> IF[FALSE]['happy']['sad']
=> "sad"
irb.txt.tx(main):099:0>
irb.txt.tx(main):100:0> -> y {
irb.txt.tx(main):101:1*       b[x][y]
irb.txt.tx(main):102:1>   }
=> #<Proc:0x000055cad0029518 programming_with_nothing/irb.txt.tx:100 (lambda)>
irb.txt.tx(main):103:0> IF =
irb.txt.tx(main):104:0*     -> b {
irb.txt.tx(main):105:1*         -> x {
irb.txt.tx(main):106:2*             b[x]
irb.txt.tx(main):107:2>         }
irb.txt.tx(main):108:1>     }
programming_with_nothing/irb.txt.tx:103: warning: already initialized constant IF
programming_with_nothing/irb.txt.tx:89: warning: previous definition of IF was here
=> #<Proc:0x000055cad0258a28 programming_with_nothing/irb.txt.tx:104 (lambda)>
irb.txt.tx(main):109:0> -> x {
irb.txt.tx(main):110:1*       b[x]
irb.txt.tx(main):111:1>   }
=> #<Proc:0x000055cad030a6b0 programming_with_nothing/irb.txt.tx:109 (lambda)>
irb.txt.tx(main):112:0>
irb.txt.tx(main):113:0> def zero?(n)
irb.txt.tx(main):114:1>     if n == 0
irb.txt.tx(main):115:2>         true
irb.txt.tx(main):116:2>       else
irb.txt.tx(main):117:2>         false
irb.txt.tx(main):118:2>       end
irb.txt.tx(main):119:1>   end
=> :zero?
irb.txt.tx(main):120:0>
irb.txt.tx(main):121:0> def zero?(proc)
irb.txt.tx(main):122:1>     proc[-> x { FALSE }][TRUE]
irb.txt.tx(main):123:1>   end
=> :zero?
irb.txt.tx(main):124:0>
irb.txt.tx(main):125:0> to_boolean(IS_ZERO[ZERO])
=> true
irb.txt.tx(main):126:0> to_boolean(IS_ZERO[THREE])
=> false
irb.txt.tx(main):127:0> -> f { f[x][y] }
=> #<Proc:0x000055cad05efb00 programming_with_nothing/irb.txt.tx:127 (lambda)>
irb.txt.tx(main):128:0> my_pair = PAIR[THREE][FIVE]
=> #<Proc:0x000055cad05e01f0 /home/yj/gnusrc/computationbook/programming_wi...
irb.txt.tx(main):129:0> to_integer(LEFT[my_pair])
=> 3
irb.txt.tx(main):130:0> to_integer(RIGHT[my_pair])
=> 5
irb.txt.tx(main):131:0>
irb.txt.tx(main):132:0> def slide(pair)
irb.txt.tx(main):133:1>     [pair.last, pair.last + 1]
irb.txt.tx(main):134:1>   end
=> :slide
irb.txt.tx(main):135:0>
irb.txt.tx(main):136:0> slide([3, 4])
=> [4, 5]
irb.txt.tx(main):137:0> slide([8, 9])
=> [9, 10]
irb.txt.tx(main):138:0> slide([-1, 0])
=> [0, 1]
irb.txt.tx(main):139:0> slide(slide([-1, 0]))
=> [1, 2]
irb.txt.tx(main):140:0> slide(slide(slide([-1, 0])))
=> [2, 3]
irb.txt.tx(main):141:0> slide(slide(slide(slide([-1, 0]))))
=> [3, 4]
irb.txt.tx(main):142:0> slide([0, 0])
=> [0, 1]
irb.txt.tx(main):143:0> slide(slide([0, 0]))
=> [1, 2]
irb.txt.tx(main):144:0> slide(slide(slide([0, 0])))
=> [2, 3]
irb.txt.tx(main):145:0> slide(slide(slide(slide([0, 0]))))
=> [3, 4]
irb.txt.tx(main):146:0> to_integer(DECREMENT[FIVE])
=> 4
irb.txt.tx(main):147:0> to_integer(DECREMENT[FIFTEEN])
=> 14
irb.txt.tx(main):148:0> to_integer(DECREMENT[HUNDRED])
=> 99
irb.txt.tx(main):149:0> to_integer(DECREMENT[ZERO])
=> 0
irb.txt.tx(main):150:0>
irb.txt.tx(main):151:0> def mod(m, n)
irb.txt.tx(main):152:1>     if n <= m
irb.txt.tx(main):153:2>         mod(m - n, n)
irb.txt.tx(main):154:2>       else
irb.txt.tx(main):155:2>         m
irb.txt.tx(main):156:2>       end
irb.txt.tx(main):157:1>   end
=> :mod
irb.txt.tx(main):158:0>
irb.txt.tx(main):159:0> def less_or_equal?(m, n)
irb.txt.tx(main):160:1>     m - n <= 0
irb.txt.tx(main):161:1>   end
=> :less_or_equal?
irb.txt.tx(main):162:0>
irb.txt.tx(main):163:0> to_integer(SUBTRACT[FIVE][THREE])
=> 2
irb.txt.tx(main):164:0> to_integer(SUBTRACT[THREE][FIVE])
=> 0
irb.txt.tx(main):165:0>
irb.txt.tx(main):166:0> def less_or_equal?(m, n)
irb.txt.tx(main):167:1>     IS_ZERO[SUBTRACT[m][n]]
irb.txt.tx(main):168:1>   end
=> :less_or_equal?
irb.txt.tx(main):169:0>
irb.txt.tx(main):170:0> to_boolean(IS_LESS_OR_EQUAL[ONE][TWO])
=> true
irb.txt.tx(main):171:0> to_boolean(IS_LESS_OR_EQUAL[TWO][TWO])
=> true
irb.txt.tx(main):172:0> to_boolean(IS_LESS_OR_EQUAL[THREE][TWO])
=> false
irb.txt.tx(main):173:0>
irb.txt.tx(main):174:0> def mod(m, n)
irb.txt.tx(main):175:1>     IF[IS_LESS_OR_EQUAL[n][m]][
irb.txt.tx(main):176:2*           mod(SUBTRACT[m][n], n)
irb.txt.tx(main):177:2>       ][
irb.txt.tx(main):178:2*           m
irb.txt.tx(main):179:2>       ]
irb.txt.tx(main):180:1>   end
=> :mod
irb.txt.tx(main):181:0>
irb.txt.tx(main):182:0> MOD =
irb.txt.tx(main):183:0*     -> m { -> n {
irb.txt.tx(main):184:2*           IF[IS_LESS_OR_EQUAL[n][m]][
irb.txt.tx(main):185:3*               MOD[SUBTRACT[m][n]][n]
irb.txt.tx(main):186:3>           ][
irb.txt.tx(main):187:3*               m
irb.txt.tx(main):188:3>           ]
irb.txt.tx(main):189:2>       } }
programming_with_nothing/irb.txt.tx:182: warning: already initialized constant MOD
/home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:45: warning: previous definition of MOD was here
=> #<Proc:0x000055cad06dc798 programming_with_nothing/irb.txt.tx:183 (lambda)>
irb.txt.tx(main):190:0> to_integer(MOD[THREE][TWO])
/home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:20:in `block (2 levels) in <top (required)>': stack level too deep (SystemStackError)
        from /home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:19:in `block (3 levels) in <top (required)>'
        from /home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:20:in `block in <top (required)>'
        from /home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:27:in `block in <top (required)>'
        from /home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:5:in `block (2 levels) in <top (required)>'
        from /home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:29:in `block (2 levels) in <top (required)>'
        from programming_with_nothing/irb.txt.tx:185:in `block (2 levels) in <main>'
        from programming_with_nothing/irb.txt.tx:185:in `block (2 levels) in <main>'
        from programming_with_nothing/irb.txt.tx:185:in `block (2 levels) in <main>'
         ... 10907 levels...
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        from /usr/bin/bundle:25:in `load'
        from /usr/bin/bundle:25:in `<main>'
irb.txt.tx(main):191:0> MOD =
irb.txt.tx(main):192:0*     -> m { -> n {
irb.txt.tx(main):193:2*           IF[IS_LESS_OR_EQUAL[n][m]][
irb.txt.tx(main):194:3*               MOD[SUBTRACT[m][n]][n]
irb.txt.tx(main):195:3>           ][
irb.txt.tx(main):196:3*               m
irb.txt.tx(main):197:3>           ]
irb.txt.tx(main):198:2>       } }
programming_with_nothing/irb.txt.tx:191: warning: already initialized constant MOD
programming_with_nothing/irb.txt.tx:182: warning: previous definition of MOD was here
=> #<Proc:0x000055cacff60528 programming_with_nothing/irb.txt.tx:192 (lambda)>
irb.txt.tx(main):199:0> MOD =
irb.txt.tx(main):200:0*     -> m { -> n {
irb.txt.tx(main):201:2*           IF[IS_LESS_OR_EQUAL[n][m]][
irb.txt.tx(main):202:3*               -> x {
irb.txt.tx(main):203:4*                   MOD[SUBTRACT[m][n]][n][x]
irb.txt.tx(main):204:4>               }
irb.txt.tx(main):205:3>           ][
irb.txt.tx(main):206:3*               m
irb.txt.tx(main):207:3>           ]
irb.txt.tx(main):208:2>       } }
programming_with_nothing/irb.txt.tx:199: warning: already initialized constant MOD
programming_with_nothing/irb.txt.tx:191: warning: previous definition of MOD was here
=> #<Proc:0x000055cad0311f78 programming_with_nothing/irb.txt.tx:200 (lambda)>
irb.txt.tx(main):209:0> to_integer(MOD[THREE][TWO])
=> 1
irb.txt.tx(main):210:0> to_integer(MOD[
irb.txt.tx(main):211:2*            POWER[THREE][THREE]
irb.txt.tx(main):212:2>        ][
irb.txt.tx(main):213:2*            ADD[THREE][TWO]
irb.txt.tx(main):214:2>        ])
=> 2
irb.txt.tx(main):215:0> to_integer(MOD[THREE][TWO])
=> 1
irb.txt.tx(main):216:0> to_integer(MOD[
irb.txt.tx(main):217:2*         POWER[THREE][THREE]
irb.txt.tx(main):218:2>     ][
irb.txt.tx(main):219:2*         ADD[THREE][TWO]
irb.txt.tx(main):220:2>     ])
=> 2
irb.txt.tx(main):221:0> my_list =
irb.txt.tx(main):222:0*     UNSHIFT[
irb.txt.tx(main):223:1*         UNSHIFT[
irb.txt.tx(main):224:2*             UNSHIFT[EMPTY][THREE]
irb.txt.tx(main):225:2>         ][TWO]
irb.txt.tx(main):226:1>     ][ONE]
=> #<Proc:0x000055cad0997fc8 /home/yj/gnusrc/computationbook/programming_wi...
irb.txt.tx(main):227:0> to_integer(FIRST[my_list])
=> 1
irb.txt.tx(main):228:0> to_integer(FIRST[REST[my_list]])
=> 2
irb.txt.tx(main):229:0> to_integer(FIRST[REST[REST[my_list]]])
=> 3
irb.txt.tx(main):230:0> to_boolean(IS_EMPTY[my_list])
=> false
irb.txt.tx(main):231:0> to_boolean(IS_EMPTY[EMPTY])
=> true
irb.txt.tx(main):232:0>
irb.txt.tx(main):233:0> to_array(my_list)
=>
[#<Proc:0x000055cad061be30 /home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:4 (lambda)>,
 #<Proc:0x000055cad061be08 /home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:5 (lambda)>,
 #<Proc:0x000055cad061bde0 /home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:6 (lambda)>]
irb.txt.tx(main):234:0> to_array(my_list).map { |p| to_integer(p) }
=> [1, 2, 3]
irb.txt.tx(main):235:0>
irb.txt.tx(main):236:0> def range(m, n)
irb.txt.tx(main):237:1>     if m <= n
irb.txt.tx(main):238:2>         range(m + 1, n).unshift(m)
irb.txt.tx(main):239:2>       else
irb.txt.tx(main):240:2>         []
irb.txt.tx(main):241:2>       end
irb.txt.tx(main):242:1>   end
=> :range
irb.txt.tx(main):243:0>
irb.txt.tx(main):244:0> my_range = RANGE[ONE][FIVE]
=> #<Proc:0x000055cad0231e50 /home/yj/gnusrc/computationbook/programming_wi...
irb.txt.tx(main):245:0> to_array(my_range).map { |p| to_integer(p) }
=> [1, 2, 3, 4, 5]
irb.txt.tx(main):246:0> to_integer(FOLD[RANGE[ONE][FIVE]][ZERO][ADD])
=> 15
irb.txt.tx(main):247:0> to_integer(FOLD[RANGE[ONE][FIVE]][ONE][MULTIPLY])
=> 120
irb.txt.tx(main):248:0> my_list = MAP[RANGE[ONE][FIVE]][INCREMENT]
=> #<Proc:0x000055cad02faf58 /home/yj/gnusrc/computationbook/programming_wi...
irb.txt.tx(main):249:0> to_array(my_list).map { |p| to_integer(p) }
=> [2, 3, 4, 5, 6]
irb.txt.tx(main):250:0>
irb.txt.tx(main):251:0> to_char(ZED)
=> "z"
irb.txt.tx(main):252:0> to_string(FIZZBUZZ)
=> "FizzBuzz"
irb.txt.tx(main):253:0>
irb.txt.tx(main):254:0> def to_digits(n)
irb.txt.tx(main):255:1>     previous_digits =
irb.txt.tx(main):256:1*         if n < 10
irb.txt.tx(main):257:2>           []
irb.txt.tx(main):258:2>         else
irb.txt.tx(main):259:2>           to_digits(n / 10)
irb.txt.tx(main):260:2>         end
irb.txt.tx(main):261:1>
irb.txt.tx(main):262:1>     previous_digits.push(n % 10)
irb.txt.tx(main):263:1>   end
=> :to_digits
irb.txt.tx(main):264:0>
irb.txt.tx(main):265:0> to_array(TO_DIGITS[FIVE]).map { |p| to_integer(p) }
=> [5]
irb.txt.tx(main):266:0> to_array(TO_DIGITS[POWER[FIVE][THREE]]).map { |p| to_integer(p) }
=> [1, 2, 5]
irb.txt.tx(main):267:0> to_string(TO_DIGITS[FIVE])
=> "5"
irb.txt.tx(main):268:0> to_string(TO_DIGITS[POWER[FIVE][THREE]])
=> "125"
irb.txt.tx(main):269:0> MAP[RANGE[ONE][HUNDRED]][-> n {
irb.txt.tx(main):270:2*         IF[IS_ZERO[MOD[n][FIFTEEN]]][
irb.txt.tx(main):271:3*             FIZZBUZZ
irb.txt.tx(main):272:3>         ][IF[IS_ZERO[MOD[n][THREE]]][
irb.txt.tx(main):273:4*               FIZZ
irb.txt.tx(main):274:4>           ][IF[IS_ZERO[MOD[n][FIVE]]][
irb.txt.tx(main):275:5*                 BUZZ
irb.txt.tx(main):276:5>             ][
irb.txt.tx(main):277:5*                 TO_DIGITS[n]
irb.txt.tx(main):278:5>             ]]]
irb.txt.tx(main):279:2>     }]
=> #<Proc:0x000055cad0878c78 /home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:94 (lambda)>
irb.txt.tx(main):280:0> to_array(solution).each do |p|
irb.txt.tx(main):281:1*       puts to_string(p)
irb.txt.tx(main):282:1>   end; nil
programming_with_nothing/irb.txt.tx:280:in `<main>': undefined local variable or method `solution' for main:Object (NameError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):283:0> ZEROS = Z[-> f { UNSHIFT[f][ZERO] }]
=> #<Proc:0x000055cad0902c70 /home/yj/gnusrc/computationbook/programming_wi...
irb.txt.tx(main):284:0> to_integer(FIRST[ZEROS])
=> 0
irb.txt.tx(main):285:0> to_integer(FIRST[REST[ZEROS]])
=> 0
irb.txt.tx(main):286:0> to_integer(FIRST[REST[REST[REST[REST[REST[ZEROS]]]]]])
=> 0
irb.txt.tx(main):287:0>
irb.txt.tx(main):288:0> def to_array(l, count = nil)
irb.txt.tx(main):289:1>     array = []
irb.txt.tx(main):290:1>
irb.txt.tx(main):291:1>     until to_boolean(IS_EMPTY[l]) || count == 0
irb.txt.tx(main):292:2>         array.push(FIRST[l])
irb.txt.tx(main):293:2>         l = REST[l]
irb.txt.tx(main):294:2>         count = count - 1 unless count.nil?
irb.txt.tx(main):295:2>       end
irb.txt.tx(main):296:1>
irb.txt.tx(main):297:1>     array
irb.txt.tx(main):298:1>   end
=> :to_array
irb.txt.tx(main):299:0>
irb.txt.tx(main):300:0> to_array(ZEROS, 5).map { |p| to_integer(p) }
=> [0, 0, 0, 0, 0]
irb.txt.tx(main):301:0> to_array(ZEROS, 10).map { |p| to_integer(p) }
=> [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
irb.txt.tx(main):302:0> to_array(ZEROS, 20).map { |p| to_integer(p) }
=> [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
irb.txt.tx(main):303:0> UPWARDS_OF = Z[-> f { -> n { UNSHIFT[-> x { f[INCREMENT[n]][x] }][n] } }]
=> #<Proc:0x000055cad0313918 programming_with_nothing/irb.txt.tx:303 (lambda)>
irb.txt.tx(main):304:0> to_array(UPWARDS_OF[ZERO], 5).map { |p| to_integer(p) }
=> [0, 1, 2, 3, 4]
irb.txt.tx(main):305:0> to_array(UPWARDS_OF[FIFTEEN], 20).map { |p| to_integer(p) }
=> [15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34]
irb.txt.tx(main):306:0> MULTIPLES_OF =
irb.txt.tx(main):307:0*     -> m {
irb.txt.tx(main):308:1*         Z[-> f {
irb.txt.tx(main):309:3*               -> n { UNSHIFT[-> x { f[ADD[m][n]][x] }][n] }
irb.txt.tx(main):310:3>           }][m]
irb.txt.tx(main):311:1>     }
=> #<Proc:0x000055cad06efd48 programming_with_nothing/irb.txt.tx:307 (lambda)>
irb.txt.tx(main):312:0> to_array(MULTIPLES_OF[TWO], 10).map { |p| to_integer(p) }
=> [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
irb.txt.tx(main):313:0> to_array(MULTIPLES_OF[FIVE], 20).map { |p| to_integer(p) }
=> [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100]
irb.txt.tx(main):314:0> to_array(MULTIPLES_OF[THREE], 10).map { |p| to_integer(p) }
=> [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]
irb.txt.tx(main):315:0> to_array(MAP[MULTIPLES_OF[THREE]][INCREMENT], 10).map { |p| to_integer(p) }
=> [4, 7, 10, 13, 16, 19, 22, 25, 28, 31]
irb.txt.tx(main):316:0> to_array(MAP[MULTIPLES_OF[THREE]][MULTIPLY[TWO]], 10).map { |p| to_integer(p) }
=> [6, 12, 18, 24, 30, 36, 42, 48, 54, 60]
irb.txt.tx(main):317:0> MULTIPLY_STREAMS =
irb.txt.tx(main):318:0*     Z[-> f {
irb.txt.tx(main):319:2*           -> k { -> l {
irb.txt.tx(main):320:4*                 UNSHIFT[-> x { f[REST[k]][REST[l]][x] }][MULTIPLY[FIRST[k]][FIRST[l]]]
irb.txt.tx(main):321:4>             } }
irb.txt.tx(main):322:2>       }]
=> #<Proc:0x000055cad073c7b0 programming_with_nothing/irb.txt.tx:319 (lambda)>
irb.txt.tx(main):323:0> to_array(MULTIPLY_STREAMS[UPWARDS_OF[ONE]][MULTIPLES_OF[THREE]], 10).
irb.txt.tx(main):324:0>   map { |p| to_integer(p) }
=> [3, 12, 27, 48, 75, 108, 147, 192, 243, 300]
irb.txt.tx(main):325:0>
irb.txt.tx(main):326:0> def multiples_of(n)
irb.txt.tx(main):327:1>     Enumerator.new do |yielder|
irb.txt.tx(main):328:2*           value = n
irb.txt.tx(main):329:2>         loop do
irb.txt.tx(main):330:3*               yielder.yield(value)
irb.txt.tx(main):331:3>             value = value + n
irb.txt.tx(main):332:3>           end
irb.txt.tx(main):333:2>       end
irb.txt.tx(main):334:1>   end
=> :multiples_of
irb.txt.tx(main):335:0>
irb.txt.tx(main):336:0> multiples_of_three = multiples_of(3)
=> #<Enumerator: ...>
irb.txt.tx(main):337:0> multiples_of_three.next
=> 3
irb.txt.tx(main):338:0> multiples_of_three.next
=> 6
irb.txt.tx(main):339:0> multiples_of_three.next
=> 9
irb.txt.tx(main):340:0> multiples_of(3).first
=> 3
irb.txt.tx(main):341:0> multiples_of(3).take(10)
=> [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]
irb.txt.tx(main):342:0> multiples_of(3).detect { |x| x > 100 }
=> 102
irb.txt.tx(main):343:0> multiples_of(3).lazy.map { |x| x * 2 }.take(10).force
=> [6, 12, 18, 24, 30, 36, 42, 48, 54, 60]
irb.txt.tx(main):344:0> multiples_of(3).lazy.map { |x| x * 2 }.select { |x| x > 100 }.take(10).force
=> [102, 108, 114, 120, 126, 132, 138, 144, 150, 156]
irb.txt.tx(main):345:0> multiples_of(3).lazy.zip(multiples_of(4)).map { |a, b| a * b }.take(10).force
=> [12, 48, 108, 192, 300, 432, 588, 768, 972, 1200]
irb.txt.tx(main):346:0>
irb.txt.tx(main):347:0> def decrease(m, n)
irb.txt.tx(main):348:1>     if n <= m
irb.txt.tx(main):349:2>         m - n
irb.txt.tx(main):350:2>       else
irb.txt.tx(main):351:2>         m
irb.txt.tx(main):352:2>       end
irb.txt.tx(main):353:1>   end
=> :decrease
irb.txt.tx(main):354:0>
irb.txt.tx(main):355:0> decrease(17, 5)
=> 12
irb.txt.tx(main):356:0> decrease(decrease(17, 5), 5)
=> 7
irb.txt.tx(main):357:0> decrease(decrease(decrease(17, 5), 5), 5)
=> 2
irb.txt.tx(main):358:0> decrease(decrease(decrease(decrease(17, 5), 5), 5), 5)
=> 2
irb.txt.tx(main):359:0> decrease(decrease(decrease(decrease(decrease(17, 5), 5), 5), 5), 5)
=> 2
irb.txt.tx(main):360:0> MOD =
irb.txt.tx(main):361:0*     -> m { -> n {
irb.txt.tx(main):362:2*           m[-> x {
irb.txt.tx(main):363:4*                 IF[IS_LESS_OR_EQUAL[n][x]][
irb.txt.tx(main):364:5*                     SUBTRACT[x][n]
irb.txt.tx(main):365:5>                 ][
irb.txt.tx(main):366:5*                     x
irb.txt.tx(main):367:5>                 ]
irb.txt.tx(main):368:4>             }][m]
irb.txt.tx(main):369:2>       } }
programming_with_nothing/irb.txt.tx:360: warning: already initialized constant MOD
programming_with_nothing/irb.txt.tx:199: warning: previous definition of MOD was here
=> #<Proc:0x000055cad05ec900 programming_with_nothing/irb.txt.tx:361 (lambda)>
irb.txt.tx(main):370:0> to_integer(MOD[THREE][TWO])
=> 1
irb.txt.tx(main):371:0> to_integer(MOD[
irb.txt.tx(main):372:2*            POWER[THREE][THREE]
irb.txt.tx(main):373:2>        ][
irb.txt.tx(main):374:2*            ADD[THREE][TWO]
irb.txt.tx(main):375:2>        ])
=> 2
irb.txt.tx(main):376:0> to_integer(MOD[THREE][ZERO])
=> 3
irb.txt.tx(main):377:0>
irb.txt.tx(main):378:0> def countdown(pair)
irb.txt.tx(main):379:1>     [pair.first.unshift(pair.last), pair.last - 1]
irb.txt.tx(main):380:1>   end
=> :countdown
irb.txt.tx(main):381:0>
irb.txt.tx(main):382:0> countdown([[], 10])
=> [[10], 9]
irb.txt.tx(main):383:0> countdown(countdown([[], 10]))
=> [[9, 10], 8]
irb.txt.tx(main):384:0> countdown(countdown(countdown([[], 10])))
=> [[8, 9, 10], 7]
irb.txt.tx(main):385:0> countdown(countdown(countdown(countdown([[], 10]))))
=> [[7, 8, 9, 10], 6]
irb.txt.tx(main):386:0> COUNTDOWN = -> p { PAIR[UNSHIFT[LEFT[p]][RIGHT[p]]][DECREMENT[RIGHT[p]]] }
=> #<Proc:0x000055cad0953490 programming_with_nothing/irb.txt.tx:386 (lambda)>
irb.txt.tx(main):387:0> RANGE = -> m { -> n { LEFT[INCREMENT[SUBTRACT[n][m]][COUNTDOWN][PAIR[EMPTY][n]]] } }
programming_with_nothing/irb.txt.tx:387: warning: already initialized constant RANGE
/home/yj/gnusrc/computationbook/programming_with_nothing/fizzbuzz/solution.rb:75: warning: previous definition of RANGE was here
=> #<Proc:0x000055cad0934d88 programming_with_nothing/irb.txt.tx:387 (lambda)>
irb.txt.tx(main):388:0> to_array(RANGE[FIVE][TEN]).map { |p| to_integer(p) }
=> [5, 6, 7, 8, 9, 10]
irb.txt.tx(main):389:0>
irb.txt.tx(main):390:0> one =
irb.txt.tx(main):391:0*     LCFunction.new(:p,
irb.txt.tx(main):392:1*         LCFunction.new(:x,
irb.txt.tx(main):393:2*             LCCall.new(LCVariable.new(:p), LCVariable.new(:x))
irb.txt.tx(main):394:2>         )
irb.txt.tx(main):395:1>     )
=> #<struct LCFunction parameter=:p, body=#<struct LCFunction parameter=:x,...
irb.txt.tx(main):396:0> increment =
irb.txt.tx(main):397:0*     LCFunction.new(:n,
irb.txt.tx(main):398:1*         LCFunction.new(:p,
irb.txt.tx(main):399:2*             LCFunction.new(:x,
irb.txt.tx(main):400:3*                 LCCall.new(
irb.txt.tx(main):401:4*                     LCVariable.new(:p),
irb.txt.tx(main):402:4*                     LCCall.new(
irb.txt.tx(main):403:5*                         LCCall.new(LCVariable.new(:n), LCVariable.new(:p)),
irb.txt.tx(main):404:5*                         LCVariable.new(:x)
irb.txt.tx(main):405:5>                     )
irb.txt.tx(main):406:4>                 )
irb.txt.tx(main):407:3>             )
irb.txt.tx(main):408:2>         )
irb.txt.tx(main):409:1>     )
=>
#<struct LCFunction
...
irb.txt.tx(main):410:0> add =
irb.txt.tx(main):411:0*     LCFunction.new(:m,
irb.txt.tx(main):412:1*         LCFunction.new(:n,
irb.txt.tx(main):413:2*             LCCall.new(LCCall.new(LCVariable.new(:n), increment), LCVariable.new(:m))
irb.txt.tx(main):414:2>         )
irb.txt.tx(main):415:1>     )
=>
#<struct LCFunction
...
irb.txt.tx(main):416:0>
irb.txt.tx(main):417:0> expression = LCVariable.new(:x)
=> #<struct LCVariable name=:x>
irb.txt.tx(main):418:0> expression.replace(:x, LCFunction.new(:y, LCVariable.new(:y)))
=> #<struct LCFunction parameter=:y, body=#<struct LCVariable name=:y>>
irb.txt.tx(main):419:0> expression.replace(:z, LCFunction.new(:y, LCVariable.new(:y)))
=> #<struct LCVariable name=:x>
irb.txt.tx(main):420:0> expression =
irb.txt.tx(main):421:0*     LCCall.new(
irb.txt.tx(main):422:1*         LCCall.new(
irb.txt.tx(main):423:2*             LCCall.new(
irb.txt.tx(main):424:3*                 LCVariable.new(:a),
irb.txt.tx(main):425:3*                 LCVariable.new(:b)
irb.txt.tx(main):426:3>             ),
irb.txt.tx(main):427:2*             LCVariable.new(:c)
irb.txt.tx(main):428:2>         ),
irb.txt.tx(main):429:1*         LCVariable.new(:b)
irb.txt.tx(main):430:1>     )
=>
#<struct LCCall
...
irb.txt.tx(main):431:0> expression.replace(:a, LCVariable.new(:x))
=>
#<struct LCCall
 left=#<struct LCCall left=#<struct LCCall left=#<struct LCVariable name=:x>, right=#<struct LCVariable name=:b>>, right=#<struct LCVariable name=:c>>,
 right=#<struct LCVariable name=:b>>
irb.txt.tx(main):432:0> expression.replace(:b, LCFunction.new(:x, LCVariable.new(:x)))
=>
#<struct LCCall
 left=
  #<struct LCCall
   left=#<struct LCCall left=#<struct LCVariable name=:a>, right=#<struct LCFunction parameter=:x, body=#<struct LCVariable name=:x>>>,
   right=#<struct LCVariable name=:c>>,
 right=#<struct LCFunction parameter=:x, body=#<struct LCVariable name=:x>>>
irb.txt.tx(main):433:0> expression =
irb.txt.tx(main):434:0*     LCFunction.new(:y,
irb.txt.tx(main):435:1*         LCCall.new(LCVariable.new(:x), LCVariable.new(:y))
irb.txt.tx(main):436:1>     )
=> #<struct LCFunction parameter=:y, body=#<struct LCCall left=#<struct LCV...
irb.txt.tx(main):437:0> expression.replace(:x, LCVariable.new(:z))
=> #<struct LCFunction parameter=:y, body=#<struct LCCall left=#<struct LCVariable name=:z>, right=#<struct LCVariable name=:y>>>
irb.txt.tx(main):438:0> expression.replace(:y, LCVariable.new(:z))
=> #<struct LCFunction parameter=:y, body=#<struct LCCall left=#<struct LCVariable name=:x>, right=#<struct LCVariable name=:y>>>
irb.txt.tx(main):439:0> expression =
irb.txt.tx(main):440:0*     LCCall.new(
irb.txt.tx(main):441:1*         LCCall.new(LCVariable.new(:x), LCVariable.new(:y)),
irb.txt.tx(main):442:1*         LCFunction.new(:y, LCCall.new(LCVariable.new(:y), LCVariable.new(:x)))
irb.txt.tx(main):443:1>     )
=>
#<struct LCCall
...
irb.txt.tx(main):444:0> expression.replace(:x, LCVariable.new(:z))
=>
#<struct LCCall
 left=#<struct LCCall left=#<struct LCVariable name=:z>, right=#<struct LCVariable name=:y>>,
 right=#<struct LCFunction parameter=:y, body=#<struct LCCall left=#<struct LCVariable name=:y>, right=#<struct LCVariable name=:z>>>>
irb.txt.tx(main):445:0> expression.replace(:y, LCVariable.new(:z))
=>
#<struct LCCall
 left=#<struct LCCall left=#<struct LCVariable name=:x>, right=#<struct LCVariable name=:z>>,
 right=#<struct LCFunction parameter=:y, body=#<struct LCCall left=#<struct LCVariable name=:y>, right=#<struct LCVariable name=:x>>>>
irb.txt.tx(main):446:0> expression =
irb.txt.tx(main):447:0*     LCFunction.new(:x,
irb.txt.tx(main):448:1*         LCCall.new(LCVariable.new(:x), LCVariable.new(:y))
irb.txt.tx(main):449:1>     )
=> #<struct LCFunction parameter=:x, body=#<struct LCCall left=#<struct LCV...
irb.txt.tx(main):450:0> replacement = LCCall.new(LCVariable.new(:z), LCVariable.new(:x))
=> #<struct LCCall left=#<struct LCVariable name=:z>, right=#<struct LCVari...
irb.txt.tx(main):451:0> expression.replace(:y, replacement)
=>
#<struct LCFunction
 parameter=:x,
 body=#<struct LCCall left=#<struct LCVariable name=:x>, right=#<struct LCCall left=#<struct LCVariable name=:z>, right=#<struct LCVariable name=:x>>>>
irb.txt.tx(main):452:0>
irb.txt.tx(main):453:0> function =
irb.txt.tx(main):454:0*     LCFunction.new(:x,
irb.txt.tx(main):455:1*         LCFunction.new(:y,
irb.txt.tx(main):456:2*             LCCall.new(LCVariable.new(:x), LCVariable.new(:y))
irb.txt.tx(main):457:2>         )
irb.txt.tx(main):458:1>     )
=> #<struct LCFunction parameter=:x, body=#<struct LCFunction parameter=:y,...
irb.txt.tx(main):459:0> argument = LCFunction.new(:z, LCVariable.new(:z))
=> #<struct LCFunction parameter=:z, body=#<struct LCVariable name=:z>>
irb.txt.tx(main):460:0> function.call(argument)
=> #<struct LCFunction parameter=:y, body=#<struct LCCall left=#<struct LCFunction parameter=:z, body=#<struct LCVariable name=:z>>, right=#<struct LCVariable name=:y>>>
irb.txt.tx(main):461:0>
irb.txt.tx(main):462:0> expression = LCCall.new(LCCall.new(add, one), one)
=>
#<struct LCCall
...
irb.txt.tx(main):463:0> while expression.reducible?
irb.txt.tx(main):464:1>     puts expression
irb.txt.tx(main):465:1>     expression = expression.reduce
irb.txt.tx(main):466:1>   end; puts expression
-> m { -> n { n[-> n { -> p { -> x { p[n[p][x]] } } }][m] } }[-> p { -> x { p[x] } }][-> p { -> x { p[x] } }]
-> n { n[-> n { -> p { -> x { p[n[p][x]] } } }][-> p { -> x { p[x] } }] }[-> p { -> x { p[x] } }]
-> p { -> x { p[x] } }[-> n { -> p { -> x { p[n[p][x]] } } }][-> p { -> x { p[x] } }]
-> x { -> n { -> p { -> x { p[n[p][x]] } } }[x] }[-> p { -> x { p[x] } }]
-> n { -> p { -> x { p[n[p][x]] } } }[-> p { -> x { p[x] } }]
-> p { -> x { p[-> p { -> x { p[x] } }[p][x]] } }
=> nil
irb.txt.tx(main):467:0> inc, zero = LCVariable.new(:inc), LCVariable.new(:zero)
=> [#<struct LCVariable name=:inc>, #<struct LCVariable name=:zero>]
irb.txt.tx(main):468:0> expression = LCCall.new(LCCall.new(expression, inc), zero)
=>
#<struct LCCall
...
irb.txt.tx(main):469:0> while expression.reducible?
irb.txt.tx(main):470:1>     puts expression
irb.txt.tx(main):471:1>     expression = expression.reduce
irb.txt.tx(main):472:1>   end; puts expression
-> p { -> x { p[-> p { -> x { p[x] } }[p][x]] } }[inc][zero]
-> x { inc[-> p { -> x { p[x] } }[inc][x]] }[zero]
inc[-> p { -> x { p[x] } }[inc][zero]]
inc[-> x { inc[x] }[zero]]
inc[inc[zero]]
=> nil
irb.txt.tx(main):473:0> require 'treetop'
=> true
irb.txt.tx(main):474:0> Treetop.load('programming_with_nothing/lambda_calculus/lambda_calculus.treetop')
=> LambdaCalculusParser
irb.txt.tx(main):475:0> parse_tree = LambdaCalculusParser.new.parse('-> x { x[x] }[-> y { y }]')
=> SyntaxNode+Calls2+Calls1 offset=0, "...{ x[x] }[-> y { y }]" (to_ast,arg...
irb.txt.tx(main):476:0> expression = parse_tree.to_ast
=>
#<struct LCCall
...
irb.txt.tx(main):477:0> expression.reduce
=> #<struct LCCall left=#<struct LCFunction parameter=:y, body=#<struct LCVariable name=:y>>, right=#<struct LCFunction parameter=:y, body=#<struct LCVariable name=:y>>>
irb.txt.tx(main):478:0> exit
irb.txt.tx(main):001:0> TAPE        = -> l { -> m { -> r { -> b { PAIR[PAIR[l][m]][PAIR[r][b]] } } } }
=> #<Proc:0x00005647d4843290 universality_is_everywhere/irb.txt.tx:1 (lambda)>
irb.txt.tx(main):002:0> TAPE_LEFT   = -> t { LEFT[LEFT[t]] }
=> #<Proc:0x00005647d485be08 universality_is_everywhere/irb.txt.tx:2 (lambda)>
irb.txt.tx(main):003:0> TAPE_MIDDLE = -> t { RIGHT[LEFT[t]] }
=> #<Proc:0x00005647d486b290 universality_is_everywhere/irb.txt.tx:3 (lambda)>
irb.txt.tx(main):004:0> TAPE_RIGHT  = -> t { LEFT[RIGHT[t]] }
=> #<Proc:0x00005647d487a768 universality_is_everywhere/irb.txt.tx:4 (lambda)>
irb.txt.tx(main):005:0> TAPE_BLANK  = -> t { RIGHT[RIGHT[t]] }
=> #<Proc:0x00005647d4889c18 universality_is_everywhere/irb.txt.tx:5 (lambda)>
irb.txt.tx(main):006:0> TAPE_WRITE = -> t { -> c { TAPE[TAPE_LEFT[t]][c][TAPE_RIGHT[t]][TAPE_BLANK[t]] } }
=> #<Proc:0x00005647d48a2e70 universality_is_everywhere/irb.txt.tx:6 (lambda)>
irb.txt.tx(main):007:0> TAPE_MOVE_HEAD_RIGHT =
irb.txt.tx(main):008:0*     -> t {
irb.txt.tx(main):009:1*         TAPE[
irb.txt.tx(main):010:2*             PUSH[TAPE_LEFT[t]][TAPE_MIDDLE[t]]
irb.txt.tx(main):011:2>         ][
irb.txt.tx(main):012:2*             IF[IS_EMPTY[TAPE_RIGHT[t]]][
irb.txt.tx(main):013:3*                 TAPE_BLANK[t]
irb.txt.tx(main):014:3>             ][
irb.txt.tx(main):015:3*                 FIRST[TAPE_RIGHT[t]]
irb.txt.tx(main):016:3>             ]
irb.txt.tx(main):017:2>         ][
irb.txt.tx(main):018:2*             IF[IS_EMPTY[TAPE_RIGHT[t]]][
irb.txt.tx(main):019:3*                 EMPTY
irb.txt.tx(main):020:3>             ][
irb.txt.tx(main):021:3*                 REST[TAPE_RIGHT[t]]
irb.txt.tx(main):022:3>             ]
irb.txt.tx(main):023:2>         ][
irb.txt.tx(main):024:2*             TAPE_BLANK[t]
irb.txt.tx(main):025:2>         ]
irb.txt.tx(main):026:1>     }
=> #<Proc:0x00005647d43cdda0 universality_is_everywhere/irb.txt.tx:8 (lambda)>
irb.txt.tx(main):027:0> current_tape = TAPE[EMPTY][ZERO][EMPTY][ZERO]
universality_is_everywhere/irb.txt.tx:27:in `<main>': uninitialized constant EMPTY (NameError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):028:0> current_tape = TAPE_WRITE[current_tape][ONE]
universality_is_everywhere/irb.txt.tx:28:in `<main>': uninitialized constant ONE (NameError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):029:0> current_tape = TAPE_MOVE_HEAD_RIGHT[current_tape]
universality_is_everywhere/irb.txt.tx:10:in `block in <main>': uninitialized constant PUSH (NameError)
        from universality_is_everywhere/irb.txt.tx:29:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):030:0> current_tape = TAPE_WRITE[current_tape][TWO]
universality_is_everywhere/irb.txt.tx:30:in `<main>': uninitialized constant TWO (NameError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):031:0> current_tape = TAPE_MOVE_HEAD_RIGHT[current_tape]
universality_is_everywhere/irb.txt.tx:10:in `block in <main>': uninitialized constant PUSH (NameError)
        from universality_is_everywhere/irb.txt.tx:31:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):032:0> current_tape = TAPE_WRITE[current_tape][THREE]
universality_is_everywhere/irb.txt.tx:32:in `<main>': uninitialized constant THREE (NameError)
Did you mean?  Thread
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):033:0> current_tape = TAPE_MOVE_HEAD_RIGHT[current_tape]
universality_is_everywhere/irb.txt.tx:10:in `block in <main>': uninitialized constant PUSH (NameError)
        from universality_is_everywhere/irb.txt.tx:33:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):034:0> to_array(TAPE_LEFT[current_tape]).map { |p| to_integer(p) }
universality_is_everywhere/irb.txt.tx:2:in `block in <main>': uninitialized constant LEFT (NameError)
        from universality_is_everywhere/irb.txt.tx:34:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):035:0> to_integer(TAPE_MIDDLE[current_tape])
universality_is_everywhere/irb.txt.tx:3:in `block in <main>': uninitialized constant RIGHT (NameError)
        from universality_is_everywhere/irb.txt.tx:35:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):036:0> to_array(TAPE_RIGHT[current_tape]).map { |p| to_integer(p) }
universality_is_everywhere/irb.txt.tx:4:in `block in <main>': uninitialized constant LEFT (NameError)
        from universality_is_everywhere/irb.txt.tx:36:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):037:0>
irb.txt.tx(main):038:0> zero
=> 0
irb.txt.tx(main):039:0> increment(zero)
=> 1
irb.txt.tx(main):040:0> increment(increment(zero))
=> 2
irb.txt.tx(main):041:0>
irb.txt.tx(main):042:0> def two
irb.txt.tx(main):043:1>     increment(increment(zero))
irb.txt.tx(main):044:1>   end
=> :two
irb.txt.tx(main):045:0>
irb.txt.tx(main):046:0> two
=> 2
irb.txt.tx(main):047:0>
irb.txt.tx(main):048:0> def three
irb.txt.tx(main):049:1>     increment(two)
irb.txt.tx(main):050:1>   end
=> :three
irb.txt.tx(main):051:0>
irb.txt.tx(main):052:0> three
=> 3
irb.txt.tx(main):053:0>
irb.txt.tx(main):054:0> def add_three(x)
irb.txt.tx(main):055:1>     increment(increment(increment(x)))
irb.txt.tx(main):056:1>   end
=> :add_three
irb.txt.tx(main):057:0>
irb.txt.tx(main):058:0> add_three(two)
=> 5
irb.txt.tx(main):059:0>
irb.txt.tx(main):060:0> def add_zero_to_x(x)
irb.txt.tx(main):061:1>     x
irb.txt.tx(main):062:1>   end
=> :add_zero_to_x
irb.txt.tx(main):063:0>
irb.txt.tx(main):064:0> def increment_easier_result(x, easier_y, easier_result)
irb.txt.tx(main):065:1>     increment(easier_result)
irb.txt.tx(main):066:1>   end
=> :increment_easier_result
irb.txt.tx(main):067:0>
irb.txt.tx(main):068:0> def add(x, y)
irb.txt.tx(main):069:1>     recurse(:add_zero_to_x, :increment_easier_result, x, y)
irb.txt.tx(main):070:1>   end
=> :add
irb.txt.tx(main):071:0>
irb.txt.tx(main):072:0> add(two, three)
=> 5
irb.txt.tx(main):073:0>
irb.txt.tx(main):074:0> def multiply_x_by_zero(x)
irb.txt.tx(main):075:1>     zero
irb.txt.tx(main):076:1>   end
=> :multiply_x_by_zero
irb.txt.tx(main):077:0>
irb.txt.tx(main):078:0> def add_x_to_easier_result(x, easier_y, easier_result)
irb.txt.tx(main):079:1>     add(x, easier_result)
irb.txt.tx(main):080:1>   end
=> :add_x_to_easier_result
irb.txt.tx(main):081:0>
irb.txt.tx(main):082:0> def multiply(x, y)
irb.txt.tx(main):083:1>     recurse(:multiply_x_by_zero, :add_x_to_easier_result, x, y)
irb.txt.tx(main):084:1>   end
=> :multiply
irb.txt.tx(main):085:0>
irb.txt.tx(main):086:0> def easier_x(easier_x, easier_result)
irb.txt.tx(main):087:1>     easier_x
irb.txt.tx(main):088:1>   end
=> :easier_x
irb.txt.tx(main):089:0>
irb.txt.tx(main):090:0> def decrement(x)
irb.txt.tx(main):091:1>     recurse(:zero, :easier_x, x)
irb.txt.tx(main):092:1>   end
=> :decrement
irb.txt.tx(main):093:0>
irb.txt.tx(main):094:0> def subtract_zero_from_x(x)
irb.txt.tx(main):095:1>     x
irb.txt.tx(main):096:1>   end
=> :subtract_zero_from_x
irb.txt.tx(main):097:0>
irb.txt.tx(main):098:0> def decrement_easier_result(x, easier_y, easier_result)
irb.txt.tx(main):099:1>     decrement(easier_result)
irb.txt.tx(main):100:1>   end
=> :decrement_easier_result
irb.txt.tx(main):101:0>
irb.txt.tx(main):102:0> def subtract(x, y)
irb.txt.tx(main):103:1>     recurse(:subtract_zero_from_x, :decrement_easier_result, x, y)
irb.txt.tx(main):104:1>   end
=> :subtract
irb.txt.tx(main):105:0>
irb.txt.tx(main):106:0> multiply(two, three)
=> 6
irb.txt.tx(main):107:0>
irb.txt.tx(main):108:0> def six
irb.txt.tx(main):109:1>     multiply(two, three)
irb.txt.tx(main):110:1>   end
=> :six
irb.txt.tx(main):111:0>
irb.txt.tx(main):112:0> decrement(six)
=> 5
irb.txt.tx(main):113:0> subtract(six, two)
=> 4
irb.txt.tx(main):114:0> subtract(two, six)
=> 0
irb.txt.tx(main):115:0>
irb.txt.tx(main):116:0> def divide(x, y)
irb.txt.tx(main):117:1>     minimize { |n| subtract(increment(x), multiply(y, increment(n))) }
irb.txt.tx(main):118:1>   end
=> :divide
irb.txt.tx(main):119:0>
irb.txt.tx(main):120:0> divide(six, two)
=> 3
irb.txt.tx(main):121:0>
irb.txt.tx(main):122:0> def ten
irb.txt.tx(main):123:1>     increment(multiply(three, three))
irb.txt.tx(main):124:1>   end
=> :ten
irb.txt.tx(main):125:0>
irb.txt.tx(main):126:0> ten
=> 10
irb.txt.tx(main):127:0> divide(ten, three)
=> 3
irb.txt.tx(main):128:0> divide(six, zero)
/home/yj/gnusrc/computationbook/universality_is_everywhere/partial_recursive_functions/partial_recursive_functions.rb:12:in `recurse': stack level too deep (SystemStackError)
        from universality_is_everywhere/irb.txt.tx:69:in `add'
        from universality_is_everywhere/irb.txt.tx:79:in `add_x_to_easier_result'
        from /home/yj/gnusrc/computationbook/universality_is_everywhere/partial_recursive_functions/partial_recursive_functions.rb:19:in `recurse'
        from /home/yj/gnusrc/computationbook/universality_is_everywhere/partial_recursive_functions/partial_recursive_functions.rb:18:in `recurse'
        from /home/yj/gnusrc/computationbook/universality_is_everywhere/partial_recursive_functions/partial_recursive_functions.rb:18:in `recurse'
        from /home/yj/gnusrc/computationbook/universality_is_everywhere/partial_recursive_functions/partial_recursive_functions.rb:18:in `recurse'
        from /home/yj/gnusrc/computationbook/universality_is_everywhere/partial_recursive_functions/partial_recursive_functions.rb:18:in `recurse'
        from /home/yj/gnusrc/computationbook/universality_is_everywhere/partial_recursive_functions/partial_recursive_functions.rb:18:in `recurse'
         ... 6898 levels...
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        from /usr/bin/bundle:25:in `load'
        from /usr/bin/bundle:25:in `<main>'
irb.txt.tx(main):129:0>
irb.txt.tx(main):130:0> x = SKISymbol.new(:x)
=> #<struct SKISymbol name=:x>
irb.txt.tx(main):131:0> expression = SKICall.new(SKICall.new(S, K), SKICall.new(I, x))
=>
#<struct SKICall
...
irb.txt.tx(main):132:0>
irb.txt.tx(main):133:0> y, z = SKISymbol.new(:y), SKISymbol.new(:z)
=> [#<struct SKISymbol name=:y>, #<struct SKISymbol name=:z>]
irb.txt.tx(main):134:0> S.call(x, y, z)
=>
#<struct SKICall
 left=#<struct SKICall left=#<struct SKISymbol name=:x>, right=#<struct SKISymbol name=:z>>,
 right=#<struct SKICall left=#<struct SKISymbol name=:y>, right=#<struct SKISymbol name=:z>>>
irb.txt.tx(main):135:0> expression = SKICall.new(SKICall.new(SKICall.new(S, x), y), z)
=>
#<struct SKICall
...
irb.txt.tx(main):136:0> combinator = expression.left.left.left
=> #<struct SKICombinator name=:S>
irb.txt.tx(main):137:0> first_argument = expression.left.left.right
=> #<struct SKISymbol name=:x>
irb.txt.tx(main):138:0> second_argument = expression.left.right
=> #<struct SKISymbol name=:y>
irb.txt.tx(main):139:0> third_argument = expression.right
=> #<struct SKISymbol name=:z>
irb.txt.tx(main):140:0> combinator.call(first_argument, second_argument, third_argument)
=>
#<struct SKICall
 left=#<struct SKICall left=#<struct SKISymbol name=:x>, right=#<struct SKISymbol name=:z>>,
 right=#<struct SKICall left=#<struct SKISymbol name=:y>, right=#<struct SKISymbol name=:z>>>
irb.txt.tx(main):141:0>
irb.txt.tx(main):142:0> expression
=>
#<struct SKICall
 left=#<struct SKICall left=#<struct SKICall left=#<struct SKICombinator name=:S>, right=#<struct SKISymbol name=:x>>, right=#<struct SKISymbol name=:y>>,
 right=#<struct SKISymbol name=:z>>
irb.txt.tx(main):143:0> combinator = expression.combinator
=> #<struct SKICombinator name=:S>
irb.txt.tx(main):144:0> arguments = expression.arguments
=> [#<struct SKISymbol name=:x>, #<struct SKISymbol name=:y>, #<struct SKIS...
irb.txt.tx(main):145:0> combinator.call(*arguments)
=>
#<struct SKICall
 left=#<struct SKICall left=#<struct SKISymbol name=:x>, right=#<struct SKISymbol name=:z>>,
 right=#<struct SKICall left=#<struct SKISymbol name=:y>, right=#<struct SKISymbol name=:z>>>
irb.txt.tx(main):146:0> expression = SKICall.new(SKICall.new(x, y), z)
=> #<struct SKICall left=#<struct SKICall left=#<struct SKISymbol name=:x>,...
irb.txt.tx(main):147:0> combinator = expression.combinator
=> #<struct SKISymbol name=:x>
irb.txt.tx(main):148:0> arguments = expression.arguments
=> [#<struct SKISymbol name=:y>, #<struct SKISymbol name=:z>]
irb.txt.tx(main):149:0> combinator.call(*arguments)
universality_is_everywhere/irb.txt.tx:149:in `<main>': undefined method `call' for x:SKISymbol (NoMethodError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):150:0> expression = SKICall.new(SKICall.new(S, x), y)
=> #<struct SKICall left=#<struct SKICall left=#<struct SKICombinator name=...
irb.txt.tx(main):151:0> combinator = expression.combinator
=> #<struct SKICombinator name=:S>
irb.txt.tx(main):152:0> arguments = expression.arguments
=> [#<struct SKISymbol name=:x>, #<struct SKISymbol name=:y>]
irb.txt.tx(main):153:0> combinator.call(*arguments)
/home/yj/gnusrc/computationbook/universality_is_everywhere/ski_calculus/ski_combinator.rb:14:in `call': wrong number of arguments (given 2, expected 3) (ArgumentError)
        from universality_is_everywhere/irb.txt.tx:153:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):154:0>
irb.txt.tx(main):155:0> def add(x, y)
irb.txt.tx(main):156:1>     x + y
irb.txt.tx(main):157:1>   end
=> :add
irb.txt.tx(main):158:0>
irb.txt.tx(main):159:0> add_method = method(:add)
=> #<Method: Object#add(x, y) universality_is_everywhere/irb.txt.tx:155>
irb.txt.tx(main):160:0> add_method.arity
=> 2
irb.txt.tx(main):161:0> expression = SKICall.new(SKICall.new(x, y), z)
=> #<struct SKICall left=#<struct SKICall left=#<struct SKISymbol name=:x>,...
irb.txt.tx(main):162:0> expression.combinator.callable?(*expression.arguments)
=> false
irb.txt.tx(main):163:0> expression = SKICall.new(SKICall.new(S, x), y)
=> #<struct SKICall left=#<struct SKICall left=#<struct SKICombinator name=...
irb.txt.tx(main):164:0> expression.combinator.callable?(*expression.arguments)
=> false
irb.txt.tx(main):165:0> expression = SKICall.new(SKICall.new(SKICall.new(S, x), y), z)
=>
#<struct SKICall
...
irb.txt.tx(main):166:0> expression.combinator.callable?(*expression.arguments)
=> true
irb.txt.tx(main):167:0>
irb.txt.tx(main):168:0> swap = SKICall.new(SKICall.new(S, SKICall.new(K, SKICall.new(S, I))), K)
=>
#<struct SKICall
...
irb.txt.tx(main):169:0> expression = SKICall.new(SKICall.new(swap, x), y)
=>
#<struct SKICall
...
irb.txt.tx(main):170:0>
irb.txt.tx(main):171:0> while expression.reducible?
irb.txt.tx(main):172:1>     puts expression
irb.txt.tx(main):173:1>     expression = expression.reduce
irb.txt.tx(main):174:1>   end; puts expression
S[K[S[I]]][K][x][y]
K[S[I]][x][K[x]][y]
S[I][K[x]][y]
I[y][K[x][y]]
y[K[x][y]]
y[x]
=> nil
irb.txt.tx(main):175:0>
irb.txt.tx(main):176:0> original = SKICall.new(SKICall.new(S, K), I)
=> #<struct SKICall left=#<struct SKICall left=#<struct SKICombinator name=...
irb.txt.tx(main):177:0> function = original.as_a_function_of(:x)
=>
#<struct SKICall
...
irb.txt.tx(main):178:0> function.reducible?
=> false
irb.txt.tx(main):179:0> expression = SKICall.new(function, y)
=>
#<struct SKICall
...
irb.txt.tx(main):180:0>
irb.txt.tx(main):181:0> while expression.reducible?
irb.txt.tx(main):182:1>     puts expression
irb.txt.tx(main):183:1>     expression = expression.reduce
irb.txt.tx(main):184:1>   end; puts expression
S[S[K[S]][K[K]]][K[I]][y]
S[K[S]][K[K]][y][K[I][y]]
K[S][y][K[K][y]][K[I][y]]
S[K[K][y]][K[I][y]]
S[K][K[I][y]]
S[K][I]
=> nil
irb.txt.tx(main):185:0>
irb.txt.tx(main):186:0> expression == original
=> true
irb.txt.tx(main):187:0> original = SKICall.new(SKICall.new(S, x), I)
=> #<struct SKICall left=#<struct SKICall left=#<struct SKICombinator name=...
irb.txt.tx(main):188:0> function = original.as_a_function_of(:x)
=>
#<struct SKICall
...
irb.txt.tx(main):189:0> expression = SKICall.new(function, y)
=>
#<struct SKICall
...
irb.txt.tx(main):190:0>
irb.txt.tx(main):191:0> while expression.reducible?
irb.txt.tx(main):192:1>     puts expression
irb.txt.tx(main):193:1>     expression = expression.reduce
irb.txt.tx(main):194:1>   end; puts expression
S[S[K[S]][I]][K[I]][y]
S[K[S]][I][y][K[I][y]]
K[S][y][I[y]][K[I][y]]
S[I[y]][K[I][y]]
S[y][K[I][y]]
S[y][I]
=> nil
irb.txt.tx(main):195:0>
irb.txt.tx(main):196:0> expression == original
=> false
irb.txt.tx(main):197:0>
irb.txt.tx(main):198:0> two = LambdaCalculusParser.new.parse('-> p { -> x { p[p[x]] } }').to_ast
universality_is_everywhere/irb.txt.tx:198:in `<main>': uninitialized constant LambdaCalculusParser (NameError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):199:0> two.to_ski
universality_is_everywhere/irb.txt.tx:199:in `<main>': undefined method `to_ski' for nil:NilClass (NoMethodError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):200:0> inc, zero = SKISymbol.new(:inc), SKISymbol.new(:zero)
=> [#<struct SKISymbol name=:inc>, #<struct SKISymbol name=:zero>]
irb.txt.tx(main):201:0> expression = SKICall.new(SKICall.new(two.to_ski, inc), zero)
universality_is_everywhere/irb.txt.tx:201:in `<main>': undefined method `to_ski' for nil:NilClass (NoMethodError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):202:0> while expression.reducible?
irb.txt.tx(main):203:1>     puts expression
irb.txt.tx(main):204:1>     expression = expression.reduce
irb.txt.tx(main):205:1>   end; puts expression
S[y][I]
=> nil
irb.txt.tx(main):206:0> identity = SKICall.new(SKICall.new(S, K), K)
=> #<struct SKICall left=#<struct SKICall left=#<struct SKICombinator name=...
irb.txt.tx(main):207:0> expression = SKICall.new(identity, x)
=>
#<struct SKICall
...
irb.txt.tx(main):208:0> while expression.reducible?
irb.txt.tx(main):209:1>     puts expression
irb.txt.tx(main):210:1>     expression = expression.reduce
irb.txt.tx(main):211:1>   end; puts expression
S[K][K][x]
K[x][K[x]]
x
=> nil
irb.txt.tx(main):212:0>
irb.txt.tx(main):213:0> expression = S.to_iota
=>
#<struct SKICall
...
irb.txt.tx(main):214:0> while expression.reducible?
irb.txt.tx(main):215:1>     puts expression
irb.txt.tx(main):216:1>     expression = expression.reduce
irb.txt.tx(main):217:1>   end; puts expression
ɩ[ɩ[ɩ[ɩ[ɩ]]]]
ɩ[ɩ[ɩ[ɩ[S][K]]]]
ɩ[ɩ[ɩ[S[S][K][K]]]]
ɩ[ɩ[ɩ[S[K][K[K]]]]]
ɩ[ɩ[S[K][K[K]][S][K]]]
ɩ[ɩ[K[S][K[K][S]][K]]]
ɩ[ɩ[K[S][K][K]]]
ɩ[ɩ[S[K]]]
ɩ[S[K][S][K]]
ɩ[K[K][S[K]]]
ɩ[K]
K[S][K]
S
=> nil
irb.txt.tx(main):218:0> expression = K.to_iota
=>
#<struct SKICall
...
irb.txt.tx(main):219:0> while expression.reducible?
irb.txt.tx(main):220:1>     puts expression
irb.txt.tx(main):221:1>     expression = expression.reduce
irb.txt.tx(main):222:1>   end; puts expression
ɩ[ɩ[ɩ[ɩ]]]
ɩ[ɩ[ɩ[S][K]]]
ɩ[ɩ[S[S][K][K]]]
ɩ[ɩ[S[K][K[K]]]]
ɩ[S[K][K[K]][S][K]]
ɩ[K[S][K[K][S]][K]]
ɩ[K[S][K][K]]
ɩ[S[K]]
S[K][S][K]
K[K][S[K]]
K
=> nil
irb.txt.tx(main):223:0> expression = I.to_iota
=> #<struct SKICall left=#<struct SKICombinator name=:ɩ>, right=#<struct SK...
irb.txt.tx(main):224:0> while expression.reducible?
irb.txt.tx(main):225:1>     puts expression
irb.txt.tx(main):226:1>     expression = expression.reduce
irb.txt.tx(main):227:1>   end; puts expression
ɩ[ɩ]
ɩ[S][K]
S[S][K][K]
S[K][K[K]]
=> nil
irb.txt.tx(main):228:0> identity = SKICall.new(SKICall.new(S, K), SKICall.new(K, K))
=>
#<struct SKICall
...
irb.txt.tx(main):229:0> expression = SKICall.new(identity, x)
=>
#<struct SKICall
...
irb.txt.tx(main):230:0> while expression.reducible?
irb.txt.tx(main):231:1>     puts expression
irb.txt.tx(main):232:1>     expression = expression.reduce
irb.txt.tx(main):233:1>   end; puts expression
S[K][K[K]][x]
K[x][K[K][x]]
K[x][K]
x
=> nil
irb.txt.tx(main):234:0> two
=> nil
irb.txt.tx(main):235:0> two.to_ski
universality_is_everywhere/irb.txt.tx:235:in `<main>': undefined method `to_ski' for nil:NilClass (NoMethodError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):236:0> two.to_ski.to_iota
universality_is_everywhere/irb.txt.tx:236:in `<main>': undefined method `to_ski' for nil:NilClass (NoMethodError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):237:0> expression = SKICall.new(SKICall.new(two.to_ski.to_iota, inc), zero)
universality_is_everywhere/irb.txt.tx:237:in `<main>': undefined method `to_ski' for nil:NilClass (NoMethodError)
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):238:0> expression = expression.reduce while expression.reducible?
=> nil
irb.txt.tx(main):239:0> expression
=> #<struct SKISymbol name=:x>
irb.txt.tx(main):240:0>
irb.txt.tx(main):241:0> rulebook = TagRulebook.new(2, [TagRule.new('a', 'aa'), TagRule.new('b', 'bbbb')])
=>
#<struct TagRulebook
...
irb.txt.tx(main):242:0> system = TagSystem.new('aabbbbbb', rulebook)
=>
#<struct TagSystem
...
irb.txt.tx(main):243:0> 4.times do
irb.txt.tx(main):244:1*       puts system.current_string
irb.txt.tx(main):245:1>     system.step
irb.txt.tx(main):246:1>   end; puts system.current_string
aabbbbbb
bbbbbbaa
bbbbaabbbb
bbaabbbbbbbb
aabbbbbbbbbbbb
=> nil
irb.txt.tx(main):247:0>
irb.txt.tx(main):248:0> rulebook = TagRulebook.new(2, [TagRule.new('a', 'cc'), TagRule.new('b', 'dddd')])
=>
#<struct TagRulebook
...
irb.txt.tx(main):249:0> system = TagSystem.new('aabbbbbb', rulebook)
=>
#<struct TagSystem
...
irb.txt.tx(main):250:0> system.run
aabbbbbb
bbbbbbcc
bbbbccdddd
bbccdddddddd
ccdddddddddddd
=> nil
irb.txt.tx(main):251:0> rulebook = TagRulebook.new(2, [TagRule.new('a', 'cc'), TagRule.new('b', 'd')])
=>
#<struct TagRulebook
...
irb.txt.tx(main):252:0> system = TagSystem.new('aabbbbbbbbbbbb', rulebook)
=>
#<struct TagSystem
...
irb.txt.tx(main):253:0> system.run
aabbbbbbbbbbbb
bbbbbbbbbbbbcc
bbbbbbbbbbccd
bbbbbbbbccdd
bbbbbbccddd
bbbbccdddd
bbccddddd
ccdddddd
=> nil
irb.txt.tx(main):254:0> rulebook = TagRulebook.new(2, [TagRule.new('a', 'ccdd'), TagRule.new('b', 'dd')])
=>
#<struct TagRulebook
...
irb.txt.tx(main):255:0> system = TagSystem.new('aabbbb', rulebook)
=>
#<struct TagSystem
...
irb.txt.tx(main):256:0> system.run
aabbbb
bbbbccdd
bbccdddd
ccdddddd
=> nil
irb.txt.tx(main):257:0> rulebook = TagRulebook.new(2, [
irb.txt.tx(main):258:2*         TagRule.new('a', 'cc'), TagRule.new('b', 'dddd'), # double
irb.txt.tx(main):259:2*         TagRule.new('c', 'eeff'), TagRule.new('d', 'ff')  # increment
irb.txt.tx(main):260:2>     ])
=>
#<struct TagRulebook
...
irb.txt.tx(main):261:0> system = TagSystem.new('aabbbb', rulebook)
=>
#<struct TagSystem
...
irb.txt.tx(main):262:0> system.run
aabbbb
bbbbcc
bbccdddd
ccdddddddd
ddddddddeeff
ddddddeeffff
ddddeeffffff
ddeeffffffff
eeffffffffff
=> nil
irb.txt.tx(main):263:0> rulebook = TagRulebook.new(2, [
irb.txt.tx(main):264:2*         TagRule.new('a', 'cc'), TagRule.new('b', 'd'),
irb.txt.tx(main):265:2*         TagRule.new('c', 'eo'), TagRule.new('d', ''),
irb.txt.tx(main):266:2*         TagRule.new('e', 'e')
irb.txt.tx(main):267:2>     ])
=>
#<struct TagRulebook
...
irb.txt.tx(main):268:0> system = TagSystem.new('aabbbbbbbb', rulebook)
=>
#<struct TagSystem
...
irb.txt.tx(main):269:0> system.run
aabbbbbbbb
bbbbbbbbcc
bbbbbbccd
bbbbccdd
bbccddd
ccdddd
ddddeo
ddeo
eo
e
=> nil
irb.txt.tx(main):270:0> system = TagSystem.new('aabbbbbbbbbb', rulebook)
=>
#<struct TagSystem
...
irb.txt.tx(main):271:0> system.run
aabbbbbbbbbb
bbbbbbbbbbcc
bbbbbbbbccd
bbbbbbccdd
bbbbccddd
bbccdddd
ccddddd
dddddeo
dddeo
deo
o
=> nil
irb.txt.tx(main):272:0>
irb.txt.tx(main):273:0> numbers = [1, 2, 3].cycle
=> #<Enumerator: ...>
irb.txt.tx(main):274:0> numbers.next
=> 1
irb.txt.tx(main):275:0> numbers.next
=> 2
irb.txt.tx(main):276:0> numbers.next
=> 3
irb.txt.tx(main):277:0> numbers.next
=> 1
irb.txt.tx(main):278:0> [:a, :b, :c, :d].cycle.take(10)
=> [:a, :b, :c, :d, :a, :b, :c, :d, :a, :b]
irb.txt.tx(main):279:0> rulebook = CyclicTagRulebook.new([
irb.txt.tx(main):280:2*         CyclicTagRule.new('1'), CyclicTagRule.new('0010'), CyclicTagRule.new('10')
irb.txt.tx(main):281:2>     ])
=> #<struct CyclicTagRulebook rules=#<Enumerator: ...>>
irb.txt.tx(main):282:0> system = TagSystem.new('11', rulebook)
=> #<struct TagSystem current_string="11", rulebook=#<struct CyclicTagRuleb...
irb.txt.tx(main):283:0> 16.times do
irb.txt.tx(main):284:1*       puts system.current_string
irb.txt.tx(main):285:1>     system.step
irb.txt.tx(main):286:1>   end; puts system.current_string
11
11
10010
001010
01010
1010
01010
1010
0100010
100010
000101
00101
0101
101
010010
10010
00101
=> nil
irb.txt.tx(main):287:0> 20.times do
irb.txt.tx(main):288:1*       puts system.current_string
irb.txt.tx(main):289:1>     system.step
irb.txt.tx(main):290:1>   end; puts system.current_string
00101
0101
101
011
11
110
101
010010
10010
00101
0101
101
011
11
110
101
010010
10010
00101
0101
101
=> nil
irb.txt.tx(main):291:0>
irb.txt.tx(main):292:0> rulebook = TagRulebook.new(2, [TagRule.new('a', 'ccdd'), TagRule.new('b', 'dd')])
=>
#<struct TagRulebook
...
irb.txt.tx(main):293:0> system = TagSystem.new('aabbbb', rulebook)
=>
#<struct TagSystem
...
irb.txt.tx(main):294:0> system.alphabet
=> ["a", "b", "c", "d"]
irb.txt.tx(main):295:0>
irb.txt.tx(main):296:0> encoder = system.encoder
=> #<struct CyclicTagEncoder alphabet=["a", "b", "c", "d"]>
irb.txt.tx(main):297:0> encoder.encode_character('c')
=> "0010"
irb.txt.tx(main):298:0> encoder.encode_string('cab')
=> "001010000100"
irb.txt.tx(main):299:0>
irb.txt.tx(main):300:0> rule = system.rulebook.rules.first
=> #<struct TagRule first_character="a", append_characters="ccdd">
irb.txt.tx(main):301:0> rule.to_cyclic(encoder)
=> #<struct CyclicTagRule first_character="1", append_characters="0010001000010001">
irb.txt.tx(main):302:0>
irb.txt.tx(main):303:0> system.rulebook.cyclic_rules(encoder)
=>
[#<struct CyclicTagRule first_character="1", append_characters="0010001000010001">,
 #<struct CyclicTagRule first_character="1", append_characters="00010001">,
 #<struct CyclicTagRule first_character="1", append_characters="">,
 #<struct CyclicTagRule first_character="1", append_characters="">]
irb.txt.tx(main):304:0>
irb.txt.tx(main):305:0> system.rulebook.cyclic_padding_rules(encoder)
=>
[#<struct CyclicTagRule first_character="1", append_characters="">,
 #<struct CyclicTagRule first_character="1", append_characters="">,
 #<struct CyclicTagRule first_character="1", append_characters="">,
 #<struct CyclicTagRule first_character="1", append_characters="">]
irb.txt.tx(main):306:0>
irb.txt.tx(main):307:0> cyclic_system = system.to_cyclic
=> #<struct TagSystem current_string="100010000100010001000100", rulebook=#...
irb.txt.tx(main):308:0> cyclic_system.run
100010000100010001000100
000100001000100010001000010001000010001
00100001000100010001000010001000010001
0100001000100010001000010001000010001
100001000100010001000010001000010001
00001000100010001000010001000010001
0001000100010001000010001000010001
001000100010001000010001000010001
01000100010001000010001000010001
1000100010001000010001000010001
00010001000100001000100001000100010001
0010001000100001000100001000100010001
010001000100001000100001000100010001
10001000100001000100001000100010001
0001000100001000100001000100010001
001000100001000100001000100010001
01000100001000100001000100010001
1000100001000100001000100010001
00010000100010000100010001000100010001
0010000100010000100010001000100010001
010000100010000100010001000100010001
10000100010000100010001000100010001
0000100010000100010001000100010001
000100010000100010001000100010001
00100010000100010001000100010001
0100010000100010001000100010001
100010000100010001000100010001
00010000100010001000100010001
0010000100010001000100010001
010000100010001000100010001
10000100010001000100010001
0000100010001000100010001
000100010001000100010001
00100010001000100010001
0100010001000100010001
100010001000100010001
00010001000100010001
0010001000100010001
010001000100010001
10001000100010001
0001000100010001
001000100010001
01000100010001
1000100010001
000100010001
00100010001
0100010001
100010001
00010001
0010001
010001
10001
0001
001
01
1

=> nil
irb.txt.tx(main):309:0> exit
irb.txt.tx(main):001:0> def euclid(x, y)
irb.txt.tx(main):002:1>     until x == y
irb.txt.tx(main):003:2>         if x > y
irb.txt.tx(main):004:3>             x = x - y
irb.txt.tx(main):005:3>           else
irb.txt.tx(main):006:3>             y = y - x
irb.txt.tx(main):007:3>           end
irb.txt.tx(main):008:2>       end
irb.txt.tx(main):009:1>
irb.txt.tx(main):010:1>     x
irb.txt.tx(main):011:1>   end
=> :euclid
irb.txt.tx(main):012:0>
irb.txt.tx(main):013:0> euclid(18, 12)
=> 6
irb.txt.tx(main):014:0> euclid(867, 5309)
=> 1
irb.txt.tx(main):015:0> puts 'hello world'
hello world
=> nil
irb.txt.tx(main):016:0> program = "puts 'hello world'"
=> "puts 'hello world'"
irb.txt.tx(main):017:0> bytes_in_binary = program.bytes.map { |byte| byte.to_s(2).rjust(8, '0') }
=>
["01110000",
...
irb.txt.tx(main):018:0> number = bytes_in_binary.join.to_i(2)
=> 9796543849500706521102980495717740021834791
irb.txt.tx(main):019:0> number = 9796543849500706521102980495717740021834791
=> 9796543849500706521102980495717740021834791
irb.txt.tx(main):020:0> bytes_in_binary = number.to_s(2).scan(/.+?(?=.{8}*\z)/)
=>
["1110000",
...
irb.txt.tx(main):021:0> program = bytes_in_binary.map { |string| string.to_i(2).chr }.join
=> "puts 'hello world'"
irb.txt.tx(main):022:0> eval program
hello world
=> nil
irb.txt.tx(main):023:0>
irb.txt.tx(main):024:0> def evaluate(program, input)
irb.txt.tx(main):025:1>     # parse program
irb.txt.tx(main):026:1*       # evaluate program on input while capturing output
irb.txt.tx(main):027:1*       # return output
irb.txt.tx(main):028:1*     end
=> :evaluate
irb.txt.tx(main):029:0>
irb.txt.tx(main):030:0> require 'stringio'
=> true
irb.txt.tx(main):031:0>
irb.txt.tx(main):032:0> def evaluate(program, input)
irb.txt.tx(main):033:1>     old_stdin, old_stdout = $stdin, $stdout
irb.txt.tx(main):034:1>     $stdin, $stdout = StringIO.new(input), (output = StringIO.new)
irb.txt.tx(main):035:1>
irb.txt.tx(main):036:1>     begin
irb.txt.tx(main):037:2>         eval program
irb.txt.tx(main):038:2>       rescue Exception => e
irb.txt.tx(main):039:2>         output.puts(e)
irb.txt.tx(main):040:2>       ensure
irb.txt.tx(main):041:2>         $stdin, $stdout = old_stdin, old_stdout
irb.txt.tx(main):042:2>       end
irb.txt.tx(main):043:1>
irb.txt.tx(main):044:1>     output.string
irb.txt.tx(main):045:1>   end
=> :evaluate
irb.txt.tx(main):046:0>
irb.txt.tx(main):047:0> evaluate('print $stdin.read.reverse', 'hello world')
=> "dlrow olleh"
irb.txt.tx(main):048:0>
irb.txt.tx(main):049:0> def evaluate_on_itself(program)
irb.txt.tx(main):050:1>     evaluate(program, program)
irb.txt.tx(main):051:1>   end
=> :evaluate_on_itself
irb.txt.tx(main):052:0>
irb.txt.tx(main):053:0> evaluate_on_itself('print $stdin.read.reverse')
=> "esrever.daer.nidts$ tnirp"
irb.txt.tx(main):054:0> x = 1
=> 1
irb.txt.tx(main):055:0> y = 2
=> 2
irb.txt.tx(main):056:0> puts x + y
3
=> nil
irb.txt.tx(main):057:0> program = '…'
=> "…"
irb.txt.tx(main):058:0> x = 1
=> 1
irb.txt.tx(main):059:0> y = 2
=> 2
irb.txt.tx(main):060:0> puts x + y
3
=> nil
irb.txt.tx(main):061:0> puts %q{Curly brackets look like { and }.}
Curly brackets look like { and }.
=> nil
irb.txt.tx(main):062:0> puts %q{An unbalanced curly bracket like } is a problem.}
irb.txt.tx(main):063:0> program = 'program = \'program = \\\'program = \\\\\\\'…\\\\\\\'\\\'\''
/usr/lib/ruby/3.0.0/irb/workspace.rb:116:in `eval': impossible_programs/irb.txt.tx:62: syntax error, unexpected local variable or method, expecting end-of-input (SyntaxError)
...alanced curly bracket like } is a problem.}
...                             ^~
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):064:0> data = %q{
irb.txt.tx(main):065:0' program = "data = %q{#{data}}" + data
irb.txt.tx(main):066:0' x = 1
irb.txt.tx(main):067:0' y = 2
irb.txt.tx(main):068:0' puts x + y
irb.txt.tx(main):069:0' }
=> "\nprogram = \"data = %q{\#{data}}\" + data\nx = 1\ny = 2\nputs x + y\n"
irb.txt.tx(main):070:0> program = "data = %q{#{data}}" + data
=> "data = %q{\nprogram = \"data = %q{\#{data}}\" + data\nx = 1\ny = 2\nput...
irb.txt.tx(main):071:0> x = 1
=> 1
irb.txt.tx(main):072:0> y = 2
=> 2
irb.txt.tx(main):073:0> puts x + y
3
=> nil
irb.txt.tx(main):074:0> puts program
data = %q{
program = "data = %q{#{data}}" + data
x = 1
y = 2
puts x + y
}
program = "data = %q{#{data}}" + data
x = 1
y = 2
puts x + y
=> nil
irb.txt.tx(main):075:0> data = %q{
irb.txt.tx(main):076:0' program = "data = %q{#{data}}" + data
irb.txt.tx(main):077:0' puts program
irb.txt.tx(main):078:0' }
=> "\nprogram = \"data = %q{\#{data}}\" + data\nputs program\n"
irb.txt.tx(main):079:0> program = "data = %q{#{data}}" + data
=> "data = %q{\nprogram = \"data = %q{\#{data}}\" + data\nputs program\n}\n...
irb.txt.tx(main):080:0> puts program
data = %q{
program = "data = %q{#{data}}" + data
puts program
}
program = "data = %q{#{data}}" + data
puts program
=> nil
irb.txt.tx(main):081:0> data = %q{
irb.txt.tx(main):082:0' program = "data = %q{#{data}}" + data
irb.txt.tx(main):083:0' puts program
irb.txt.tx(main):084:0' }
=> "\nprogram = \"data = %q{\#{data}}\" + data\nputs program\n"
irb.txt.tx(main):085:0> program = "data = %q{#{data}}" + data
=> "data = %q{\nprogram = \"data = %q{\#{data}}\" + data\nputs program\n}\n...
irb.txt.tx(main):086:0> puts program
data = %q{
program = "data = %q{#{data}}" + data
puts program
}
program = "data = %q{#{data}}" + data
puts program
=> nil
irb.txt.tx(main):087:0>
irb.txt.tx(main):088:0> def halts?(program, input)
irb.txt.tx(main):089:1>     if program.include?('while true')
irb.txt.tx(main):090:2>         false
irb.txt.tx(main):091:2>       else
irb.txt.tx(main):092:2>         true
irb.txt.tx(main):093:2>       end
irb.txt.tx(main):094:1>   end
=> :halts?
irb.txt.tx(main):095:0>
irb.txt.tx(main):096:0> always = "input = $stdin.read\nputs input.upcase"
=> "input = $stdin.read\nputs input.upcase"
irb.txt.tx(main):097:0> halts?(always, 'hello world')
=> true
irb.txt.tx(main):098:0> never = "input = $stdin.read\nwhile true\n# do nothing\nend\nputs input.upcase"
=> "input = $stdin.read\nwhile true\n# do nothing\nend\nputs input.upcase"
irb.txt.tx(main):099:0> halts?(never, 'hello world')
=> false
irb.txt.tx(main):100:0>
irb.txt.tx(main):101:0> def halts?(program, input)
irb.txt.tx(main):102:1>     if program.include?('while true')
irb.txt.tx(main):103:2>         if program.include?('input.include?(\'goodbye\')')
irb.txt.tx(main):104:3>             if input.include?('goodbye')
irb.txt.tx(main):105:4>                 false
irb.txt.tx(main):106:4>               else
irb.txt.tx(main):107:4>                 true
irb.txt.tx(main):108:4>               end
irb.txt.tx(main):109:3>           else
irb.txt.tx(main):110:3>             false
irb.txt.tx(main):111:3>           end
irb.txt.tx(main):112:2>       else
irb.txt.tx(main):113:2>         true
irb.txt.tx(main):114:2>       end
irb.txt.tx(main):115:1>   end
=> :halts?
irb.txt.tx(main):116:0>
irb.txt.tx(main):117:0> halts?(always, 'hello world')
=> true
irb.txt.tx(main):118:0> halts?(never, 'hello world')
=> false
irb.txt.tx(main):119:0> sometimes = "input = $stdin.read\nif input.include?('goodbye')\nwhile true\n# do nothing\nend\nelse\nputs input.upcase\nend"
=> "input = $stdin.read\nif input.include?('goodbye')\nwhile true\n# do not...
irb.txt.tx(main):120:0> halts?(sometimes, 'hello world')
=> true
irb.txt.tx(main):121:0> halts?(sometimes, 'goodbye world')
=> false
irb.txt.tx(main):122:0>
irb.txt.tx(main):123:0> def halts?(program, input)
irb.txt.tx(main):124:1>     # parse program
irb.txt.tx(main):125:1*       # analyze program
irb.txt.tx(main):126:1*       # return true if program halts on input, false if not
irb.txt.tx(main):127:1*     end
=> :halts?
irb.txt.tx(main):128:0>
irb.txt.tx(main):129:0> def halts_on_itself?(program)
irb.txt.tx(main):130:1>     halts?(program, program)
irb.txt.tx(main):131:1>   end
=> :halts_on_itself?
irb.txt.tx(main):132:0>
irb.txt.tx(main):133:0> def prints_hello_world?(program, input)
irb.txt.tx(main):134:1>     # parse program
irb.txt.tx(main):135:1*       # analyze program
irb.txt.tx(main):136:1*       # return true if program prints "hello world", false if not
irb.txt.tx(main):137:1*     end
=> :prints_hello_world?
irb.txt.tx(main):138:0>
irb.txt.tx(main):139:0> def halts?(program, input)
irb.txt.tx(main):140:1>     hello_world_program = %Q{
irb.txt.tx(main):141:1"     program = #{program.inspect}
irb.txt.tx(main):142:1"     input = $stdin.read
irb.txt.tx(main):143:1"     evaluate(program, input) # evaluate program, ignoring its output
irb.txt.tx(main):144:1"     print 'hello world'
irb.txt.tx(main):145:1"   }
irb.txt.tx(main):146:1>
irb.txt.tx(main):147:1>     prints_hello_world?(hello_world_program, input)
irb.txt.tx(main):148:1>   end
=> :halts?
irb.txt.tx(main):149:0> exit
irb.txt.tx(main):001:0> 6 * -9
=> -54
irb.txt.tx(main):002:0> (6 * -9) < 0
=> true
irb.txt.tx(main):003:0> (1000 * -5) < 0
=> true
irb.txt.tx(main):004:0> (1 * -1) < 0
=> true
irb.txt.tx(main):005:0>
irb.txt.tx(main):006:0> Sign::POSITIVE * Sign::POSITIVE
=> #<struct Sign name=:positive>
irb.txt.tx(main):007:0> Sign::NEGATIVE * Sign::ZERO
=> #<struct Sign name=:zero>
irb.txt.tx(main):008:0> Sign::POSITIVE * Sign::NEGATIVE
=> #<struct Sign name=:negative>
irb.txt.tx(main):009:0>
irb.txt.tx(main):010:0> 6.sign
=> #<struct Sign name=:positive>
irb.txt.tx(main):011:0> -9.sign
=> #<struct Sign name=:negative>
irb.txt.tx(main):012:0> 6.sign * -9.sign
=> #<struct Sign name=:negative>
irb.txt.tx(main):013:0>
irb.txt.tx(main):014:0> def calculate(x, y, z)
irb.txt.tx(main):015:1>     (x * y) * (x * z)
irb.txt.tx(main):016:1>   end
=> :calculate
irb.txt.tx(main):017:0>
irb.txt.tx(main):018:0> calculate(3, -5, 0)
=> 0
irb.txt.tx(main):019:0> calculate(Sign::POSITIVE, Sign::NEGATIVE, Sign::ZERO)
=> #<struct Sign name=:zero>
irb.txt.tx(main):020:0> (6 * -9).sign == (6.sign * -9.sign)
=> true
irb.txt.tx(main):021:0> (100 * 0).sign == (100.sign * 0.sign)
=> true
irb.txt.tx(main):022:0> calculate(1, -2, -3).sign == calculate(1.sign, -2.sign, -3.sign)
=> true
irb.txt.tx(main):023:0>
irb.txt.tx(main):024:0> Sign::POSITIVE + Sign::POSITIVE
=> #<struct Sign name=:positive>
irb.txt.tx(main):025:0> Sign::NEGATIVE + Sign::ZERO
=> #<struct Sign name=:negative>
irb.txt.tx(main):026:0> Sign::NEGATIVE + Sign::POSITIVE
=> #<struct Sign name=:unknown>
irb.txt.tx(main):027:0> Sign::POSITIVE + Sign::UNKNOWN
=> #<struct Sign name=:unknown>
irb.txt.tx(main):028:0> Sign::UNKNOWN + Sign::ZERO
=> #<struct Sign name=:unknown>
irb.txt.tx(main):029:0> Sign::POSITIVE + Sign::NEGATIVE + Sign::NEGATIVE
=> #<struct Sign name=:unknown>
irb.txt.tx(main):030:0>
irb.txt.tx(main):031:0> (Sign::POSITIVE + Sign::NEGATIVE) * Sign::ZERO + Sign::POSITIVE
=> #<struct Sign name=:positive>
irb.txt.tx(main):032:0> (10 + 3).sign == (10.sign + 3.sign)
=> true
irb.txt.tx(main):033:0> (-5 + 0).sign == (-5.sign + 0.sign)
=> true
irb.txt.tx(main):034:0> (6 + -9).sign == (6.sign + -9.sign)
=> false
irb.txt.tx(main):035:0> (6 + -9).sign
=> #<struct Sign name=:negative>
irb.txt.tx(main):036:0> 6.sign + -9.sign
=> #<struct Sign name=:unknown>
irb.txt.tx(main):037:0>
irb.txt.tx(main):038:0> Sign::POSITIVE <= Sign::POSITIVE
=> true
irb.txt.tx(main):039:0> Sign::POSITIVE <= Sign::UNKNOWN
=> true
irb.txt.tx(main):040:0> Sign::POSITIVE <= Sign::NEGATIVE
=> false
irb.txt.tx(main):041:0> (6 * -9).sign <= (6.sign * -9.sign)
=> true
irb.txt.tx(main):042:0> (-5 + 0).sign <= (-5.sign + 0.sign)
=> true
irb.txt.tx(main):043:0> (6 + -9).sign <= (6.sign + -9.sign)
=> true
irb.txt.tx(main):044:0>
irb.txt.tx(main):045:0> def sum_of_squares(x, y)
irb.txt.tx(main):046:1>     (x * x) + (y * y)
irb.txt.tx(main):047:1>   end
=> :sum_of_squares
irb.txt.tx(main):048:0>
irb.txt.tx(main):049:0> inputs = Sign::NEGATIVE, Sign::ZERO, Sign::POSITIVE
=> [#<struct Sign name=:negative>, #<struct Sign name=:zero>, #<struct Sign...
irb.txt.tx(main):050:0> outputs = inputs.product(inputs).map { |x, y| sum_of_squares(x, y) }
=>
[#<struct Sign name=:positive>,
...
irb.txt.tx(main):051:0> outputs.uniq
=> [#<struct Sign name=:positive>, #<struct Sign name=:zero>]
irb.txt.tx(main):052:0> expression = Add.new(Variable.new(:x), Number.new(1))
=> #<struct Add left=#<struct Variable name=:x>, right=#<struct Number valu...
irb.txt.tx(main):053:0> expression.evaluate({ x: Number.new(2) })
programming_in_toyland/irb.txt.tx:53:in `<main>': undefined method `evaluate' for \xC2\xABx + 1\xC2\xBB:Add (NoMethodError)
Did you mean?  values_at
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):054:0> statement = Assign.new(:y, Number.new(3))
=> #<struct Assign name=:y, expression=#<struct Number value=3>>
irb.txt.tx(main):055:0> statement.evaluate({ x: Number.new(1) })
programming_in_toyland/irb.txt.tx:55:in `<main>': undefined method `evaluate' for \xC2\xABy = 3\xC2\xBB:Assign (NoMethodError)
Did you mean?  values_at
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):056:0>
irb.txt.tx(main):057:0> Add.new(Number.new(1), Number.new(2)).evaluate({})
programming_in_toyland/irb.txt.tx:57:in `<main>': undefined method `evaluate' for \xC2\xAB1 + 2\xC2\xBB:Add (NoMethodError)
Did you mean?  values_at
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):058:0> Add.new(Number.new(1), Boolean.new(true)).evaluate({})
programming_in_toyland/irb.txt.tx:58:in `<main>': undefined method `evaluate' for \xC2\xAB1 + true\xC2\xBB:Add (NoMethodError)
Did you mean?  values_at
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):059:0>
irb.txt.tx(main):060:0> Add.new(Number.new(1), Number.new(2)).type
/home/yj/gnusrc/computationbook/programming_in_toyland/types/add.rb:5:in `type': wrong number of arguments (given 0, expected 1) (ArgumentError)
        from programming_in_toyland/irb.txt.tx:60:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):061:0> Add.new(Number.new(1), Boolean.new(true)).type
/home/yj/gnusrc/computationbook/programming_in_toyland/types/add.rb:5:in `type': wrong number of arguments (given 0, expected 1) (ArgumentError)
        from programming_in_toyland/irb.txt.tx:61:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):062:0> LessThan.new(Number.new(1), Number.new(2)).type
/home/yj/gnusrc/computationbook/programming_in_toyland/types/less_than.rb:5:in `type': wrong number of arguments (given 0, expected 1) (ArgumentError)
        from programming_in_toyland/irb.txt.tx:62:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):063:0> LessThan.new(Number.new(1), Boolean.new(true)).type
/home/yj/gnusrc/computationbook/programming_in_toyland/types/less_than.rb:5:in `type': wrong number of arguments (given 0, expected 1) (ArgumentError)
        from programming_in_toyland/irb.txt.tx:63:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):064:0> bad_expression = Add.new(Number.new(true), Number.new(1))
=> #<struct Add left=#<struct Number value=true>, right=#<struct Number val...
irb.txt.tx(main):065:0> bad_expression.type
/home/yj/gnusrc/computationbook/programming_in_toyland/types/add.rb:5:in `type': wrong number of arguments (given 0, expected 1) (ArgumentError)
        from programming_in_toyland/irb.txt.tx:65:in `<main>'
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        ... 3 levels...
irb.txt.tx(main):066:0> bad_expression.evaluate({})
programming_in_toyland/irb.txt.tx:66:in `<main>': undefined method `evaluate' for \xC2\xABtrue + 1\xC2\xBB:Add (NoMethodError)
Did you mean?  values_at
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):067:0>
irb.txt.tx(main):068:0> expression = Add.new(Variable.new(:x), Variable.new(:y))
=> #<struct Add left=#<struct Variable name=:x>, right=#<struct Variable na...
irb.txt.tx(main):069:0> expression.type({})
=> nil
irb.txt.tx(main):070:0> expression.type({ x: Type::NUMBER, y: Type::NUMBER })
=> #<struct Type name=:number>
irb.txt.tx(main):071:0> expression.type({ x: Type::NUMBER, y: Type::BOOLEAN })
=> nil
irb.txt.tx(main):072:0>
irb.txt.tx(main):073:0> If.new(
irb.txt.tx(main):074:1*       LessThan.new(Number.new(1), Number.new(2)), DoNothing.new, DoNothing.new
irb.txt.tx(main):075:1>   ).type({})
=> #<struct Type name=:void>
irb.txt.tx(main):076:0> If.new(
irb.txt.tx(main):077:1*       Add.new(Number.new(1), Number.new(2)), DoNothing.new, DoNothing.new
irb.txt.tx(main):078:1>   ).type({})
=> nil
irb.txt.tx(main):079:0> While.new(Variable.new(:x), DoNothing.new).type({ x: Type::BOOLEAN })
=> #<struct Type name=:void>
irb.txt.tx(main):080:0> While.new(Variable.new(:x), DoNothing.new).type({ x: Type::NUMBER })
=> nil
irb.txt.tx(main):081:0>
irb.txt.tx(main):082:0> statement =
irb.txt.tx(main):083:0*     While.new(
irb.txt.tx(main):084:1*         LessThan.new(Variable.new(:x), Number.new(5)),
irb.txt.tx(main):085:1*         Assign.new(:x, Add.new(Variable.new(:x), Number.new(3)))
irb.txt.tx(main):086:1>     )
=>
#<struct While
...
irb.txt.tx(main):087:0> statement.type({})
=> nil
irb.txt.tx(main):088:0> statement.type({ x: Type::NUMBER })
=> #<struct Type name=:void>
irb.txt.tx(main):089:0> statement.type({ x: Type::BOOLEAN })
=> nil
irb.txt.tx(main):090:0> statement =
irb.txt.tx(main):091:0*     Sequence.new(
irb.txt.tx(main):092:1*         Assign.new(:x, Number.new(0)),
irb.txt.tx(main):093:1*         While.new(
irb.txt.tx(main):094:2*             Boolean.new(true),
irb.txt.tx(main):095:2*             Assign.new(:x, Add.new(Variable.new(:x), Number.new(1)))
irb.txt.tx(main):096:2>         )
irb.txt.tx(main):097:1>     )
=>
#<struct Sequence
...
irb.txt.tx(main):098:0> statement.type({ x: Type::NUMBER })
=> #<struct Type name=:void>
irb.txt.tx(main):099:0> statement.evaluate({})
programming_in_toyland/irb.txt.tx:99:in `<main>': undefined method `evaluate' for \xC2\xABx = 0; while (true) { x = x + 1 }\xC2\xBB:Sequence (NoMethodError)
Did you mean?  values_at
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):100:0> statement = Sequence.new(statement, Assign.new(:x, Boolean.new(true)))
=>
#<struct Sequence
...
irb.txt.tx(main):101:0> statement.type({ x: Type::NUMBER })
=> nil
irb.txt.tx(main):102:0> statement =
irb.txt.tx(main):103:0*     Sequence.new(
irb.txt.tx(main):104:1*         If.new(
irb.txt.tx(main):105:2*             Variable.new(:b),
irb.txt.tx(main):106:2*             Assign.new(:x, Number.new(6)),
irb.txt.tx(main):107:2*             Assign.new(:x, Boolean.new(true))
irb.txt.tx(main):108:2>         ),
irb.txt.tx(main):109:1*         Sequence.new(
irb.txt.tx(main):110:2*             If.new(
irb.txt.tx(main):111:3*                 Variable.new(:b),
irb.txt.tx(main):112:3*                 Assign.new(:y, Variable.new(:x)),
irb.txt.tx(main):113:3*                 Assign.new(:y, Number.new(1))
irb.txt.tx(main):114:3>             ),
irb.txt.tx(main):115:2*             Assign.new(:z, Add.new(Variable.new(:y), Number.new(1)))
irb.txt.tx(main):116:2>         )
irb.txt.tx(main):117:1>     )
=>
#<struct Sequence
...
irb.txt.tx(main):118:0> statement.evaluate({ b: Boolean.new(true) })
programming_in_toyland/irb.txt.tx:118:in `<main>': undefined method `evaluate' for \xC2\xABif (b) { x = 6 } else { x = true }; if (b) { y = x } else { y = 1 }; z = y + 1\xC2\xBB:Sequence (NoMethodError)
Did you mean?  values_at
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):119:0> statement.evaluate({ b: Boolean.new(false) })
programming_in_toyland/irb.txt.tx:119:in `<main>': undefined method `evaluate' for \xC2\xABif (b) { x = 6 } else { x = true }; if (b) { y = x } else { y = 1 }; z = y + 1\xC2\xBB:Sequence (NoMethodError)
Did you mean?  values_at
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):120:0> statement.type({})
=> nil
irb.txt.tx(main):121:0> context = { b: Type::BOOLEAN, y: Type::NUMBER, z: Type::NUMBER }
=> {:b=>#<struct Type name=:boolean>, :y=>#<struct Type name=:number>, :z=>...
irb.txt.tx(main):122:0> statement.type(context)
=> nil
irb.txt.tx(main):123:0> statement.type(context.merge({ x: Type::NUMBER }))
=> nil
irb.txt.tx(main):124:0> statement.type(context.merge({ x: Type::BOOLEAN }))
=> nil
irb.txt.tx(main):125:0> statement = Assign.new(:x, Add.new(Variable.new(:x), Number.new(1)))
=> #<struct Assign name=:x, expression=#<struct Add left=#<struct Variable ...
irb.txt.tx(main):126:0> statement.type({ x: Type::NUMBER })
=> #<struct Type name=:void>
irb.txt.tx(main):127:0> statement.evaluate({})
programming_in_toyland/irb.txt.tx:127:in `<main>': undefined method `evaluate' for \xC2\xABx = x + 1\xC2\xBB:Assign (NoMethodError)
Did you mean?  values_at
        from /usr/lib/ruby/gems/3.0.0/gems/irb-1.3.5/exe/irb:11:in `<top (required)>'
        from /usr/bin/irb:23:in `load'
        from /usr/bin/irb:23:in `<top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:58:in `kernel_load'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli/exec.rb:23:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:484:in `exec'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/command.rb:27:in `run'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/invocation.rb:127:in `invoke_command'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor.rb:392:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:31:in `dispatch'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/vendor/thor/lib/thor/base.rb:485:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/cli.rb:25:in `start'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:48:in `block in <top (required)>'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/lib/bundler/friendly_errors.rb:103:in `with_friendly_errors'
        from /usr/share/rubygems-integration/all/gems/bundler-2.3.5/exe/bundle:36:in `<top (required)>'
        ... 2 levels...
irb.txt.tx(main):128:0> exit
yj@yjlee1:~/gnusrc/computationbook$
